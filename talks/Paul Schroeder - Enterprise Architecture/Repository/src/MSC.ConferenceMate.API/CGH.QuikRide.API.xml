<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MSC.ConferenceMate.API</name>
    </assembly>
    <members>
        <member name="P:MSC.ConferenceMate.API.Controllers.CM.CMBaseApiController.Log">
             <summary>
            
             </summary>
             <remarks>
             This is private for a reason - using ILoggingService here in place of Log4NetLoggingService would be preferable.
             However, doing so causes the CallerMemberName and CallerFilePath attributes to return null.
             This is because those attributes are used by the compiler (not at runtime) to do their magic.
             Thus, by abstracting them in an interface the compiler cannot tell which methods are calling.
             </remarks>
        </member>
        <member name="P:MSC.ConferenceMate.API.Controllers.CM.CMBaseApiControllerAuthorized.Log">
             <summary>
            
             </summary>
             <remarks>
             This is private for a reason - using ILoggingService here in place of Log4NetLoggingService would be preferable.
             However, doing so causes the CallerMemberName and CallerFilePath attributes to return null.
             This is because those attributes are used by the compiler (not at runtime) to do their magic.
             Thus, by abstracting them in an interface the compiler cannot tell which methods are calling.
             </remarks>
        </member>
        <member name="M:MSC.ConferenceMate.API.Startup.ConfigureOAuthForJWT(Owin.IAppBuilder)">
            <summary>
            Configure JWT usage - path, duration, and format of token.
            </summary>
            <param name="app"></param>
        </member>
        <member name="M:MSC.ConferenceMate.API.Startup.ConfigureJWTConsumption(Owin.IAppBuilder)">
            <summary>
            Handles consuming a JWT, which enables use of the [Authorize] attributes on controllers.
            </summary>
            <param name="app"></param>
        </member>
        <member name="T:DryIoc.Container">
            <summary>IoC Container. Documentation is available at https://bitbucket.org/dadhi/dryioc. </summary>
        </member>
        <member name="M:DryIoc.Container.#ctor">
            <summary>Creates new container with default rules <see cref="F:DryIoc.Rules.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.Container.#ctor(DryIoc.Rules,DryIoc.IScopeContext)">
            <summary>Creates new container, optionally providing <see cref="P:DryIoc.Container.Rules"/> to modify default container behavior.</summary>
            <param name="rules">(optional) Rules to modify container default resolution behavior.
            If not specified, then <see cref="F:DryIoc.Rules.Default"/> will be used.</param>
            <param name="scopeContext">(optional) Scope context to use for scoped reuse.</param>
        </member>
        <member name="M:DryIoc.Container.#ctor(System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Creates new container with configured rules.</summary>
            <param name="configure">Allows to modify <see cref="F:DryIoc.Rules.Default"/> rules.</param>
            <param name="scopeContext">(optional) Scope context to use for <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</param>
        </member>
        <member name="M:DryIoc.Container.NewSingletonScope">
            <summary>Helper to create singleton scope</summary>
        </member>
        <member name="M:DryIoc.Container.ToString">
            <summary>Outputs info about container disposal state and current scopes.</summary>
        </member>
        <member name="M:DryIoc.Container.Dispose">
            <summary>Dispose either open scope, or container with singletons, if no scope opened.</summary>
        </member>
        <member name="M:DryIoc.Container.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.</summary>
            <remarks>Decorator and Wrapper types are not included.</remarks>
        </member>
        <member name="M:DryIoc.Container.GetRegisteredFactories(System.Type,System.Object,DryIoc.FactoryType)">
            <summary>Searches for registered factories by type, and key (if specified),
            and by factory type (by default uses <see cref="F:DryIoc.FactoryType.Service"/>).
            May return empty, 1 or multiple factories.</summary>
        </member>
        <member name="M:DryIoc.Container.Register(DryIoc.Factory,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean)">
            <summary>Stores factory into container using <paramref name="serviceType"/> and <paramref name="serviceKey"/> as key
            for later lookup.</summary>
            <param name="factory">Any subtypes of <see cref="T:DryIoc.Factory"/>.</param>
            <param name="serviceType">Type of service to resolve later.</param>
            <param name="serviceKey">(optional) Service key of any type with <see cref="M:System.Object.GetHashCode"/> and <see cref="M:System.Object.Equals(System.Object)"/>
            implemented.</param>
            <param name="ifAlreadyRegistered">(optional) Says how to handle existing registration with the same
            <paramref name="serviceType"/> and <paramref name="serviceKey"/>.</param>
            <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise.
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.Container.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.System#IServiceProvider#GetService(System.Type)">
            Resolves service with <see cref="F:DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered"/> policy,
            enabling the fallback resolution for not registered services (default MS convention)
        </member>
        <member name="P:DryIoc.Container.Parent">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.Root">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.SingletonScope">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.ScopeContext">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Container.CurrentScope">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.WithCurrentScope(DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.UseInstance(System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please just use `RegisterInstance` or <see cref="M:DryIoc.Container.Use(System.Type,DryIoc.FactoryDelegate)"/> method instead.
        </member>
        <member name="M:DryIoc.Container.Use(System.Type,DryIoc.FactoryDelegate)">
            Adding the factory directly to scope for resolution 
        </member>
        <member name="P:DryIoc.Container.Rules">
            <summary>The rules object defines policies per container for registration and resolution.</summary>
        </member>
        <member name="P:DryIoc.Container.OwnCurrentScope">
            <summary>Represents scope bound to container itself, and not an ambient (context) thingy.</summary>
        </member>
        <member name="P:DryIoc.Container.IsDisposed">
            <summary>Indicates that container is disposed.</summary>
        </member>
        <member name="M:DryIoc.Container.With(DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional) Controls what to do with the next registration: ignore or throw exception.
            Throws exception by default.</param>
        </member>
        <member name="M:DryIoc.Container.ClearCache(System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Container.GetConstantExpression(System.Object,System.Type,System.Boolean)">
            <summary>Converts known item into literal expression or wraps it in a constant expression.</summary>
        </member>
        <member name="M:DryIoc.Container.InstanceFactory.UseInterpretation(DryIoc.Request)">
            Switched off until I (or someone) will figure it out.
        </member>
        <member name="M:DryIoc.Container.InstanceFactory.GetDelegateOrDefault(DryIoc.Request)">
            Tries to return instance directly from scope or sigleton, and fallbacks to expression for decorator.
        </member>
        <member name="M:DryIoc.Container.InstanceFactory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Called for Injection as dependency.</summary>
        </member>
        <member name="T:DryIoc.OpenGenericTypeKey">
            Special service key with info about open-generic service type
        </member>
        <member name="F:DryIoc.OpenGenericTypeKey.RequiredServiceType">
            <summary>Open-generic required service-type</summary>
        </member>
        <member name="F:DryIoc.OpenGenericTypeKey.ServiceKey">
            <summary>Optional key</summary>
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.#ctor(System.Type,System.Object)">
            <summary>Constructs the thingy</summary>
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.ToString">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.OpenGenericTypeKey.ToExpression(System.Func{System.Object,FastExpressionCompiler.LightExpression.Expression})">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.HiddenDisposable">
            <summary>Hides/wraps object with disposable interface.</summary> 
        </member>
        <member name="F:DryIoc.HiddenDisposable.Value">
            <summary>Wrapped value</summary>
        </member>
        <member name="M:DryIoc.HiddenDisposable.#ctor(System.Object)">
            <summary>Wraps the value</summary>
        </member>
        <member name="T:DryIoc.Interpreter">
            Interpreter of expression - where possible uses knowledge of DryIoc internals to avoid reflection
        </member>
        <member name="M:DryIoc.Interpreter.TryInterpretAndUnwrapContainerException(DryIoc.IResolverContext,FastExpressionCompiler.LightExpression.Expression,System.Boolean,System.Object@)">
            Calls `TryInterpret` inside try-catch and unwraps/rethrows `ContainerException` from the reflection `TargetInvocationException`
        </member>
        <member name="M:DryIoc.Interpreter.TryInterpret(DryIoc.IResolverContext,FastExpressionCompiler.LightExpression.Expression,System.Boolean,System.Object@)">
            Interprets passed expression
        </member>
        <member name="T:DryIoc.FactoryDelegateCompiler">
            <summary>Compiles expression to factory delegate.</summary>
        </member>
        <member name="F:DryIoc.FactoryDelegateCompiler.ResolverContextParamExpr">
            <summary>Resolver context parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.NormalizeExpression(FastExpressionCompiler.LightExpression.Expression)">
            Strips the unnecessary or adds the necessary cast to expression return result
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.WrapInFactoryExpression(FastExpressionCompiler.LightExpression.Expression)">
            <summary>Wraps service creation expression (body) into <see cref="T:DryIoc.FactoryDelegate"/> and returns result lambda expression.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.CompileToFactoryDelegate(FastExpressionCompiler.LightExpression.Expression,System.Boolean)">
            <summary>First wraps the input service expression into lambda expression and
            then compiles lambda expression to actual <see cref="T:DryIoc.FactoryDelegate"/> used for service resolution.</summary>
        </member>
        <member name="M:DryIoc.FactoryDelegateCompiler.ToExpression(FastExpressionCompiler.LightExpression.Expression)">
            <summary>Restores the expression from LightExpression, or returns itself if already an Expression.</summary>
        </member>
        <member name="T:DryIoc.ContainerTools">
            <summary>Container extended features.</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.FacadeKey">
            <summary>The default key for services registered into container created by <see cref="M:DryIoc.ContainerTools.CreateFacade(DryIoc.IContainer,System.String)"/></summary>
        </member>
        <member name="M:DryIoc.ContainerTools.CreateFacade(DryIoc.IContainer,System.String)">
            <summary>Allows to register new specially keyed services which will facade the same default service,
            registered earlier. May be used to "override" registrations when testing the container</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.With(DryIoc.IContainer,System.Func{DryIoc.Rules,DryIoc.Rules},DryIoc.IScopeContext)">
            <summary>Shares all of container state except the cache and the new rules.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithExpressionGeneration(DryIoc.IContainer,System.Boolean)">
            <summary>Prepares container for expression generation.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithoutCache(DryIoc.IContainer)">
            <summary>Returns new container with all expression, delegate, items cache removed/reset.
            But it will preserve resolved services in Singleton/Current scope.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithoutSingletonsAndCache(DryIoc.IContainer)">
            <summary>Creates new container with state shared with original, except for the singletons and cache.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithRegistrationsCopy(DryIoc.IContainer,System.Boolean)">
            <summary>Shares the setup with original container but copies the registrations, so the new registrations
            won't be visible in original. Registrations include decorators and wrappers as well.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.InjectPropertiesAndFields``1(DryIoc.IResolverContext,``0)">
            <summary>For given instance resolves and sets properties and fields.
            It respects <see cref="P:DryIoc.Rules.PropertiesAndFields"/> rules set per container,
            or if rules are not set it uses <see cref="F:DryIoc.PropertiesAndFields.Auto"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.InjectPropertiesAndFields``1(DryIoc.IResolverContext,``0,System.String[])">
            <summary>For given instance resolves and sets properties and fields. You may specify what 
            properties and fields.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.New(DryIoc.IContainer,System.Type,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="concreteType">Type to instantiate. Wrappers (Func, Lazy, etc.) is also supported.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, 
            properties and fields.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made,DryIoc.RegistrySharing)">
            <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
            <typeparam name="T">Type to instantiate.</typeparam>
            <param name="container">Container to use for type creation and injecting its dependencies.</param>
            <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Object instantiated by constructor or object returned by factory method.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.New``1(DryIoc.IContainer,DryIoc.Made.TypedMade{``0},DryIoc.RegistrySharing)">
            <summary>Creates service given strongly-typed creation expression.
            Can be used to invoke arbitrary method returning some value with injecting its parameters from container.</summary>
            <typeparam name="T">Method or constructor result type.</typeparam>
            <param name="container">Container to use for injecting dependencies.</param>
            <param name="made">Creation expression.</param>
            <param name="registrySharing">The default is <see cref="F:DryIoc.RegistrySharing.CloneButKeepCache"/></param>
            <returns>Created result.</returns>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterMapping(DryIoc.IContainer,System.Type,System.Type,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param> <param name="serviceType">New service type.</param>
            <param name="registeredServiceType">Existing registered service type.</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <remarks>Does nothing if registration is already exists.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterMapping``2(DryIoc.IContainer,System.Object,System.Object)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="container">Container</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <remarks>Does nothing if registration is already exists.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterPlaceholder(DryIoc.IContainer,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Forwards to <see cref="M:DryIoc.Registrator.RegisterPlaceholder(DryIoc.IRegistrator,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.RegisterPlaceholder``1(DryIoc.IContainer,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Register a service without implementation which can be provided later in terms
            of normal registration with IfAlreadyRegistered.Replace parameter.
            When the implementation is still not provided when the placeholder service is accessed,
            then the exception will be thrown.
            This feature allows you to postpone decision on implementation until it is later known.</summary>
            <remarks>Internally the empty factory is registered with the setup asResolutionCall set to true.
            That means, instead of placing service instance into graph expression we put here redirecting call to
            container Resolve.</remarks>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            Obsolete: please use WithAutoFallbackDynamicRegistration
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackResolution(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            Obsolete: please use WithAutoFallbackDynamicRegistration
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.IReuse,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,DryIoc.IReuse,DryIoc.Setup,System.Type[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Reflection.Assembly}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Reflection.Assembly[])">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithAutoFallbackDynamicRegistrations(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>Provides automatic fallback resolution mechanism for not normally registered
            services. Underneath uses <see cref="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.WithDependencies(DryIoc.IContainer,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates new container with provided parameters and properties
            to pass the custom dependency values for injection. The old parameters and properties are overridden,
            but not replaced.</summary>
            <param name="container">Container to work with.</param>
            <param name="parameters">(optional) Parameters specification, can be used to proved custom values.</param>
            <param name="propertiesAndFields">(optional) Properties and fields specification, can be used to proved custom values.</param>
            <returns>New container with adjusted rules.</returns>
            <example><code lang="cs"><![CDATA[
                var c = container.WithDependencies(Parameters.Of.Type<string>(_ => "Nya!"));
                var a = c.Resolve<A>(); // where A accepts string parameter in constructor
                Assert.AreEqual("Nya!", a.Message)
            ]]></code></example>
        </member>
        <member name="T:DryIoc.ContainerTools.GeneratedExpressions">
            <summary>Result of GenerateResolutionExpressions methods</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.Roots">
            <summary>Resolutions roots</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.ResolveDependencies">
            <summary>Dependency of Resolve calls</summary>
        </member>
        <member name="F:DryIoc.ContainerTools.GeneratedExpressions.Errors">
            <summary>Errors</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Func{System.Collections.Generic.IEnumerable{DryIoc.ServiceRegistrationInfo},System.Collections.Generic.IEnumerable{DryIoc.ServiceInfo}},System.Boolean)">
            <summary>Generates expressions for specified roots and their "Resolve-call" dependencies.
            Wraps exceptions into errors. The method does not create any actual services.
            You may use Factory <see cref="P:DryIoc.Setup.AsResolutionRoot"/>.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Generates expressions for provided root services</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GenerateResolutionExpressions(DryIoc.IContainer,DryIoc.ServiceInfo[])">
            <summary>Generates expressions for provided root services</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.DefaultValidateCondition(DryIoc.ServiceRegistrationInfo)">
            <summary>Excluding open-generic registrations, cause you need to provide type arguments to actually create these types.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,System.Func{DryIoc.ServiceRegistrationInfo,System.Boolean})">
            <summary>Helps to find potential problems in service registration setup.
            Method tries to resolve the specified registrations, collects exceptions, and
            returns them to user. Does not create any actual service objects.
            You must specify <paramref name="condition"/> to define your resolution roots,
            otherwise container will try to resolve all registrations, 
            which usually is not realistic case to validate. </summary>
        </member>
        <member name="M:DryIoc.ContainerTools.Validate(DryIoc.IContainer,DryIoc.ServiceInfo[])">
            <summary>Helps to find potential problems when resolving the <paramref name="roots"/>.
            Method will collect the exceptions when resolving or injecting the specific root.
            Does not create any actual service objects.
            You must specify <paramref name="roots"/> to define your resolution roots,
            otherwise container will try to resolve all registrations, 
            which usually is not realistic case to validate. </summary>
        </member>
        <member name="M:DryIoc.ContainerTools.GetRequestExpression(DryIoc.IContainer,DryIoc.Request,DryIoc.RequestFlags)">
            <summary>Re-constructs the whole request chain as request creation expression.</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ClearCache``1(DryIoc.IContainer,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears delegate and expression cache for specified <typeparamref name="T"/>.
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
        </member>
        <member name="M:DryIoc.ContainerTools.ClearCache(DryIoc.IContainer,System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears delegate and expression cache for specified service.
            But does not clear instances of already resolved/created singletons and scoped services!</summary>
        </member>
        <member name="T:DryIoc.IConvertibleToExpression">
            <summary>Interface used to convert reuse instance to expression.</summary>
        </member>
        <member name="M:DryIoc.IConvertibleToExpression.ToExpression(System.Func{System.Object,FastExpressionCompiler.LightExpression.Expression})">
            <summary>Returns expression representation without closure.
            Use <paramref name="fallbackConverter"/> to converting the sub-items, constants to container.</summary>
        </member>
        <member name="T:DryIoc.DefaultKey">
            <summary>Used to represent multiple default service keys.
            Exposes <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/> to determine order of service added.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultKey.RegistrationOrder">
            <summary>Allows to determine service registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Of(System.Int32)">
            <summary>Returns the default key with specified registration order.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.ToExpression(System.Func{System.Object,FastExpressionCompiler.LightExpression.Expression})">
            <summary>Converts to expression</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Next">
            <summary>Returns next default key with increased <see cref="F:DryIoc.DefaultKey.RegistrationOrder"/>.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.Equals(System.Object)">
            <summary>Compares keys based on registration order. The null (represents default) key is considered equal.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.GetHashCode">
            <summary>Returns registration order as hash.</summary>
        </member>
        <member name="M:DryIoc.DefaultKey.ToString">
            <summary>Prints registration order to string.</summary>
        </member>
        <member name="T:DryIoc.DefaultDynamicKey">
            <summary>Represents default key for dynamic registrations</summary>
        </member>
        <member name="F:DryIoc.DefaultDynamicKey.Value">
            <summary>Default value.</summary>
        </member>
        <member name="F:DryIoc.DefaultDynamicKey.RegistrationOrder">
            <summary>Associated ID.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Of(System.Int32)">
            <summary>Returns dynamic key with specified ID.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.ToExpression(System.Func{System.Object,FastExpressionCompiler.LightExpression.Expression})">
            <summary>Converts to expression</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Next">
            <summary>Returns next dynamic key with increased <see cref="F:DryIoc.DefaultDynamicKey.RegistrationOrder"/>.</summary> 
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.Equals(System.Object)">
            <summary>Compares key's IDs. The null (default) key is considered equal!</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.GetHashCode">
            <summary>Returns key index as hash.</summary>
        </member>
        <member name="M:DryIoc.DefaultDynamicKey.ToString">
            <summary>Prints registration order to string.</summary>
        </member>
        <member name="T:DryIoc.IResolverContext">
            <summary>Extends IResolver to provide an access to scope hierarchy.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.IsDisposed">
            <summary>True if container is disposed.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Parent">
            <summary>Parent context of the scoped context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.Root">
            <summary>The root context of the scoped context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.SingletonScope">
            <summary>Singleton scope, always associated with root scope.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.ScopeContext">
            <summary>Optional ambient scope context.</summary>
        </member>
        <member name="P:DryIoc.IResolverContext.CurrentScope">
            <summary>Current opened scope. May return the current scope from <see cref="P:DryIoc.IResolverContext.ScopeContext"/> if context is not null.</summary>
        </member>
        <member name="M:DryIoc.IResolverContext.WithCurrentScope(DryIoc.IScope)">
            <summary>Creates resolver context with specified current scope (or container which implements the context).</summary>
        </member>
        <member name="M:DryIoc.IResolverContext.UseInstance(System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Put instance into the current scope or singletons.
        </member>
        <member name="M:DryIoc.IResolverContext.Use(System.Type,DryIoc.FactoryDelegate)">
            Puts instance created via the passed factory on demand into the current or singleton scope
        </member>
        <member name="M:DryIoc.IResolverContext.InjectPropertiesAndFields(System.Object,System.String[])">
            <summary>For given instance resolves and sets properties and fields.</summary>
        </member>
        <member name="T:DryIoc.ResolverContext">
            <summary>Provides a usable abstractions for <see cref="T:DryIoc.IResolverContext"/></summary>
        </member>
        <member name="M:DryIoc.ResolverContext.RootOrSelf(DryIoc.IResolverContext)">
            <summary>Just a sugar that allow to get root or self container.</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.GetRootOrSelfExpr(DryIoc.Request)">
            <summary>Returns root or self resolver based on request.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.ParentExpr">
            <summary>Resolver context parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.RootOrSelfExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.SingletonScopeExpr">
            <summary>Resolver parameter expression in FactoryDelegate.</summary>
        </member>
        <member name="F:DryIoc.ResolverContext.CurrentScopeExpr">
            <summary>Access to scopes in FactoryDelegate.</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.IsScoped(DryIoc.IResolverContext)">
            <summary>Indicates that context is scoped, have an open scope</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.GetCurrentScope(DryIoc.IResolverContext,System.Boolean)">
            <summary>Provides access to the current scope.</summary>
        </member>
        <member name="M:DryIoc.ResolverContext.GetNamedScope(DryIoc.IResolverContext,System.Object,System.Boolean)">
            <summary>Gets current scope matching the <paramref name="name"/></summary>
        </member>
        <member name="M:DryIoc.ResolverContext.OpenScope(DryIoc.IResolverContext,System.Object,System.Boolean)">
            <summary>Opens scope with optional name and optional tracking of new scope in a parent scope.</summary>
            <param name="r">Parent context to use.</param>
            <param name="name">(optional)</param>
            <param name="trackInParent">(optional) Instructs to additionally store the opened scope in parent, 
            so it will be disposed when parent is disposed. If no parent scope is available the scope will be tracked by Singleton scope.
            Used to dispose a resolution scope.</param>
            <returns>Scoped resolver context.</returns>
            <example><code lang="cs"><![CDATA[
            using (var scope = container.OpenScope())
            {
                var handler = scope.Resolve<IHandler>();
                handler.Handle(data);
            }
            ]]></code></example>
        </member>
        <member name="M:DryIoc.ResolverContext.TrackDisposable``1(DryIoc.IResolverContext,``0)">
            A bit if sugar to track disposable in singlteon or current scope
        </member>
        <member name="T:DryIoc.FactoryDelegate">
            <summary>The result generated delegate used for service creation.</summary>
        </member>
        <member name="T:DryIoc.WrappersSupport">
            <summary>Adds to Container support for:
            <list type="bullet">
            <item>Open-generic services</item>
            <item>Service generics wrappers and arrays using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> extension point.
            Supported wrappers include: Func of <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, Lazy, Many, IEnumerable, arrays, Meta, KeyValuePair, DebugExpression.
            All wrapper factories are added into collection of <see cref="F:DryIoc.WrappersSupport.Wrappers"/>.
            unregistered resolution rule.</item>
            </list></summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.FuncTypes">
            <summary>Supported Func types.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.ActionTypes">
            <summary>Supported Action types. Yeah, action I can resolve or inject void returning method as action.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.SupportedCollectionTypes">
            <summary>Supported open-generic collection types - all the interfaces implemented by array.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.IsFunc(System.Type)">
            <summary>Returns true if type is supported <see cref="F:DryIoc.WrappersSupport.FuncTypes"/>, and false otherwise.</summary>
        </member>
        <member name="F:DryIoc.WrappersSupport.Wrappers">
            <summary>Registered wrappers by their concrete or generic definition service type.</summary>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetLazyExpressionOrDefault(DryIoc.Request,System.Boolean)">
            <summary>Gets the expression for <see cref="T:System.Lazy`1"/> wrapper.</summary>
            <param name="request">The resolution request.</param>
            <param name="nullWrapperForUnresolvedService">if set to <c>true</c> then check for service registration before creating resolution expression.</param>
            <returns>Expression: <c><![CDATA[r => new Lazy<TService>(() => r.Resolve{TService}(key, ifUnresolved, requiredType))]]></c></returns>
        </member>
        <member name="M:DryIoc.WrappersSupport.GetMetaExpressionOrDefault(DryIoc.Request)">
            <summary>Discovers and combines service with its setup metadata.
            Works with any generic type with first Type arg - Service type and second Type arg - Metadata type,
            and constructor with Service and Metadata arguments respectively.
            - if service key is not specified in request then method will search for all
            registered factories with the same metadata type ignoring keys.
            - if metadata is IDictionary{string, object},
             then the First value matching the TMetadata type will be returned.</summary>
        </member>
        <member name="T:DryIoc.DynamicRegistration">
            <summary>Represents info required for dynamic registration: service key, factory,
            and <see cref="F:DryIoc.DynamicRegistration.IfAlreadyRegistered"/> option how to combine dynamic with normal registrations.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.Factory">
            <summary>Factory</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.IfAlreadyRegistered">
            <summary>Optional: will be <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/> by default.</summary>
        </member>
        <member name="F:DryIoc.DynamicRegistration.ServiceKey">
            <summary>Optional service key: if null the default <see cref="T:DryIoc.DefaultDynamicKey"/> will be used. </summary>
        </member>
        <member name="M:DryIoc.DynamicRegistration.#ctor(DryIoc.Factory,DryIoc.IfAlreadyRegistered,System.Object)">
            <summary>Constructs the info</summary>
        </member>
        <member name="T:DryIoc.Rules">
            <summary> Defines resolution/registration rules associated with Container instance. They may be different for different containers.</summary>
        </member>
        <member name="F:DryIoc.Rules.Default">
            Default rules as staring point.
        </member>
        <member name="F:DryIoc.Rules.MicrosoftDependencyInjectionRules">
            Default rules as staring point.
        </member>
        <member name="F:DryIoc.Rules.DefaultDependencyDepthToSplitObjectGraph">
            <summary>Default value for <see cref="P:DryIoc.Rules.DependencyDepthToSplitObjectGraph"/></summary>
        </member>
        <member name="P:DryIoc.Rules.DependencyDepthToSplitObjectGraph">
            <summary>Nested dependency depth to split an object graph</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDependencyDepthToSplitObjectGraph(System.Int32)">
            <summary>Sets <see cref="P:DryIoc.Rules.DependencyDepthToSplitObjectGraph"/>.
            Set <see cref="F:System.Int32.MaxValue"/> to prevent split.
            To disable the limit please use <see cref="M:DryIoc.Rules.WithoutDependencyDepthToSplitObjectGraph"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutDependencyDepthToSplitObjectGraph">
            <summary>Disables the <see cref="P:DryIoc.Rules.DependencyDepthToSplitObjectGraph"/> limitation.</summary>
        </member>
        <member name="P:DryIoc.Rules.FactoryMethod">
            <summary>Shorthand to <see cref="P:DryIoc.Made.FactoryMethod"/></summary>
        </member>
        <member name="P:DryIoc.Rules.Parameters">
            <summary>Shorthand to <see cref="P:DryIoc.Made.Parameters"/></summary>
        </member>
        <member name="P:DryIoc.Rules.PropertiesAndFields">
            <summary>Shorthand to <see cref="P:DryIoc.Made.PropertiesAndFields"/></summary>
        </member>
        <member name="P:DryIoc.Rules.OverrideRegistrationMade">
            <summary>Instructs to override per-registration made settings with these rules settings.</summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Returns new instance of the rules new Made composed out of
            provided factory method, parameters, propertiesAndFields.</summary>
        </member>
        <member name="M:DryIoc.Rules.With(DryIoc.Made,System.Boolean)">
            <summary>Returns new instance of the rules with specified <see cref="T:DryIoc.Made"/>.</summary>
            <param name="made">New Made.Of rules.</param>
            <param name="overrideRegistrationMade">Instructs to override registration level Made.Of</param>
            <returns>New rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.DefaultRegistrationServiceKey">
            <summary>Service key to be used instead on `null` in registration.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultRegistrationServiceKey(System.Object)">
            <summary>Sets the <see cref="P:DryIoc.Rules.DefaultRegistrationServiceKey"/></summary>
        </member>
        <member name="T:DryIoc.Rules.FactorySelectorRule">
            <summary>Defines single factory selector delegate.</summary>
            <param name="request">Provides service request leading to factory selection.</param>
            <param name="factories">Registered factories with corresponding key to select from.</param>
            <returns>Single selected factory, or null if unable to select.</returns>
        </member>
        <member name="P:DryIoc.Rules.FactorySelector">
            <summary>Rules to select single matched factory default and keyed registered factory/factories.
            Selectors applied in specified array order, until first returns not null <see cref="T:DryIoc.Factory"/>.
            Default behavior is to throw on multiple registered default factories, cause it is not obvious what to use.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFactorySelector(DryIoc.Rules.FactorySelectorRule)">
            <summary>Sets <see cref="P:DryIoc.Rules.FactorySelector"/></summary>
        </member>
        <member name="M:DryIoc.Rules.SelectLastRegisteredFactory">
            <summary>Select last registered factory from the multiple default.</summary>
        </member>
        <member name="M:DryIoc.Rules.SelectKeyedOverDefaultFactory(System.Object)">
            <summary>Prefer specified service key (if found) over default key.
            Help to override default registrations in Open Scope scenarios:
            I may register service with key and resolve it as default in current scope.</summary>
        </member>
        <member name="T:DryIoc.Rules.DynamicRegistrationProvider">
            <summary>Specify the method signature for returning multiple keyed factories.
            This is dynamic analog to the normal Container Registry.</summary>
            <param name="serviceType">Requested service type.</param>
            <param name="serviceKey">(optional) If <c>null</c> will request all factories of <paramref name="serviceType"/></param>
            <returns>Key-Factory pairs.</returns>
        </member>
        <member name="P:DryIoc.Rules.DynamicRegistrationProviders">
            <summary>Providers for resolving multiple not-registered services. Null by default.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrations(DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Appends dynamic registration rules.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDynamicRegistrationsAsFallback(DryIoc.Rules.DynamicRegistrationProvider[])">
            <summary>Appends dynamic registration rules 
            And additionally specifies to use dynamic registrations only when no normal registrations found!</summary>
            <param name="rules">Rules to append.</param> <returns>New Rules.</returns>
        </member>
        <member name="P:DryIoc.Rules.UseDynamicRegistrationsAsFallbackOnly">
            Specifies to use dynamic registrations only when no normal registrations found
        </member>
        <member name="T:DryIoc.Rules.UnknownServiceResolver">
            <summary>Defines delegate to return factory for request not resolved by registered factories or prior rules.
            Applied in specified array order until return not null <see cref="T:DryIoc.Factory"/>.</summary>
        </member>
        <member name="P:DryIoc.Rules.UnknownServiceResolvers">
            <summary>Gets rules for resolving not-registered services. Null by default.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])">
            <summary>Appends resolver to current unknown service resolvers.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutUnknownServiceResolver(DryIoc.Rules.UnknownServiceResolver)">
            <summary>Removes specified resolver from unknown service resolvers, and returns new Rules.
            If no resolver was found then <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/> will stay the same instance,
            so it could be check for remove success or fail.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithUnknownServiceHandler(System.Action{DryIoc.Request})">
            <summary>Sugar on top of <see cref="M:DryIoc.Rules.WithUnknownServiceResolvers(DryIoc.Rules.UnknownServiceResolver[])"/> to simplify setting the diagnostic action.
            Does not guard you from action throwing an exception. Actually can be used to throw your custom exception
            instead of <see cref="T:DryIoc.ContainerException"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.AutoResolveConcreteTypeRule(System.Func{DryIoc.Request,System.Boolean})">
            <summary>The alternative is ConcreteTypeDynamicRegistrations</summary>
        </member>
        <member name="M:DryIoc.Rules.ConcreteTypeDynamicRegistrations(System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Rule to automatically resolves non-registered service type which is: nor interface, nor abstract.
            For constructor selection we are using <see cref="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments"/>.
            The resolution creates transient services.</summary>
            <param name="condition">(optional) Condition for requested service type and key.</param>
            <param name="reuse">(optional) Reuse for concrete types.</param>
            <returns>New rule.</returns>
        </member>
        <member name="M:DryIoc.Rules.WithConcreteTypeDynamicRegistrations(System.Func{System.Type,System.Object,System.Boolean},DryIoc.IReuse)">
            <summary>Automatically resolves non-registered service type which is: nor interface, nor abstract.
            The resolution creates Transient services.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithAutoConcreteTypeResolution(System.Func{DryIoc.Request,System.Boolean})">
            Replaced with `WithConcreteTypeDynamicRegistrations`
        </member>
        <member name="M:DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})">
            <summary>Creates dynamic fallback registrations for the requested service type
            with provided <paramref name="getImplementationTypes"/>.
            Fallback means that the dynamic registrations will be applied Only if no normal registrations
            exist for the requested service type, hence the "fallback".</summary>
            <param name="getImplementationTypes">Implementation types to select for service.</param>
            <param name="factory">(optional) Handler to customize the factory, e.g.
            specify reuse or setup. Handler should not return <c>null</c>.</param>
            <returns>Registration provider.</returns>
        </member>
        <member name="M:DryIoc.Rules.AutoRegisterUnknownServiceRule(System.Collections.Generic.IEnumerable{System.Type},System.Func{DryIoc.IReuse,DryIoc.Request,DryIoc.IReuse},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Obsolete: replaced by <see cref="M:DryIoc.Rules.AutoFallbackDynamicRegistrations(System.Func{System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,DryIoc.Factory})"/></summary>
        </member>
        <member name="P:DryIoc.Rules.DefaultReuse">
            <summary>See <see cref="M:DryIoc.Rules.WithDefaultReuse(DryIoc.IReuse)"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultReuse(DryIoc.IReuse)">
            <summary>The reuse used in case if reuse is unspecified (null) in Register methods.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultReuseInsteadOfTransient(DryIoc.IReuse)">
            <summary>Replaced by WithDefaultReuse because for some cases InsteadOfTransient does not make sense.</summary>
        </member>
        <member name="T:DryIoc.Rules.ItemToExpressionConverterRule">
            <summary>Given item object and its type should return item "pure" expression presentation,
            without side-effects or external dependencies.
            e.g. for string "blah" <code lang="cs"><![CDATA[]]>Expression.Constant("blah", typeof(string))</code>.
            If unable to convert should return null.</summary>
        </member>
        <member name="P:DryIoc.Rules.ItemToExpressionConverter">
            <summary><see cref="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithItemToExpressionConverter(DryIoc.Rules.ItemToExpressionConverterRule)">
            <summary>Specifies custom rule to convert non-primitive items to their expression representation.
            That may be required because DryIoc by default does not support non-primitive service keys and registration metadata.
            To enable non-primitive values support DryIoc need a way to recreate them as expression tree.</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfDependencyHasShorterReuseLifespan">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowIfDependencyHasShorterReuseLifespan">
            <summary>Turns off throwing exception when dependency has shorter reuse lifespan than its parent or ancestor.</summary>
            <returns>New rules with new setting value.</returns>
        </member>
        <member name="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient">
            <summary><see cref="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutThrowOnRegisteringDisposableTransient">
            <summary>Turns Off the rule <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.
            Allows to register disposable transient but it is up to you to handle their disposal.
            You can use <see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/> to actually track disposable transient in
            container, so that disposal will be handled by container.</summary>
        </member>
        <member name="P:DryIoc.Rules.TrackingDisposableTransients">
            <summary><see cref="M:DryIoc.Rules.WithTrackingDisposableTransients"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithTrackingDisposableTransients">
             <summary>Turns tracking of disposable transients in dependency parent scope, or in current scope if service
             is resolved directly.
            
             If there is no open scope at the moment then resolved transient won't be tracked and it is up to you
             to dispose it! That's is similar situation to creating service by new - you have full control.
            
             If dependency wrapped in Func somewhere in parent chain then it also won't be tracked, because
             Func supposedly means multiple object creation and for container it is not clear what to do, so container
             delegates that to user. Func here is the similar to Owned relationship type in Autofac library.
             </summary>
             <remarks>Turning this setting On automatically turns off <see cref="P:DryIoc.Rules.ThrowOnRegisteringDisposableTransient"/>.</remarks>
        </member>
        <member name="P:DryIoc.Rules.EagerCachingSingletonForFasterAccess">
            <summary><see cref="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutEagerCachingSingletonForFasterAccess">
            <summary>Turns off optimization: creating singletons during resolution of object graph.</summary>
        </member>
        <member name="P:DryIoc.Rules.DependencyResolutionCallExprs">
            <summary><see cref="M:DryIoc.Rules.WithExpressionGeneration(System.Boolean)"/>.</summary>
        </member>
        <member name="P:DryIoc.Rules.UsedForExpressionGeneration">
            Indicates that container is used for generation purposes, so it should use less runtime state
        </member>
        <member name="M:DryIoc.Rules.WithExpressionGeneration(System.Boolean)">
            <summary>Specifies to generate ResolutionCall dependency creation expression and stores the result 
            in the-per rules collection.</summary>
        </member>
        <member name="M:DryIoc.Rules.ForValidate">
            <summary>Specifies to generate ResolutionCall dependency creation expression and stores the result 
            in the-per rules collection.</summary>
        </member>
        <member name="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope">
            <summary><see cref="P:DryIoc.Rules.ImplicitCheckForReuseMatchingScope"/></summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutImplicitCheckForReuseMatchingScope">
            <summary>Removes implicit Factory <see cref="P:DryIoc.Setup.Condition"/> for non-transient service.
            The Condition filters out factory without matching scope.</summary>
        </member>
        <member name="M:DryIoc.Rules.ForExpressionGeneration(System.Boolean)">
            <summary>Removes runtime optimizations preventing an expression generation.</summary>
        </member>
        <member name="P:DryIoc.Rules.ResolveIEnumerableAsLazyEnumerable">
            <summary><see cref="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithResolveIEnumerableAsLazyEnumerable">
            <summary>Specifies to resolve IEnumerable as LazyEnumerable.</summary>
        </member>
        <member name="P:DryIoc.Rules.VariantGenericTypesInResolvedCollection">
            <summary><see cref="M:DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithoutVariantGenericTypesInResolvedCollection">
            <summary>Flag instructs to include covariant compatible types in resolved collection.</summary>
        </member>
        <member name="P:DryIoc.Rules.DefaultIfAlreadyRegistered">
            <summary><seew cref="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithDefaultIfAlreadyRegistered(DryIoc.IfAlreadyRegistered)">
            <summary>Specifies default setting for container. By default is <see cref="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed"/>.
            Example of use: specify Keep as a container default, then set AppendNonKeyed for explicit collection registrations.</summary>
        </member>
        <member name="P:DryIoc.Rules.ThrowIfRuntimeStateRequired">
            <summary><see cref="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithThrowIfRuntimeStateRequired">
            <summary>Specifies to throw an exception in attempt to resolve service which require runtime state for resolution.
            Runtime state may be introduced by RegisterDelegate, RegisterInstance, or registering with non-primitive service key, or metadata.</summary>
        </member>
        <member name="P:DryIoc.Rules.CaptureContainerDisposeStackTrace">
            <summary><see cref="M:DryIoc.Rules.WithCaptureContainerDisposeStackTrace"/>.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithCaptureContainerDisposeStackTrace">
            <summary>Instructs to capture Dispose stack-trace to include it later into <see cref="F:DryIoc.Error.ContainerIsDisposed"/>
            exception for easy diagnostics.</summary>
        </member>
        <member name="P:DryIoc.Rules.IgnoringReuseForFuncWithArgs">
            <summary>Allows Func with args specify its own reuse (sharing) behavior.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithIgnoringReuseForFuncWithArgs">
            <summary>Allows Func with args specify its own reuse (sharing) behavior.</summary>
        </member>
        <member name="P:DryIoc.Rules.FuncAndLazyWithoutRegistration">
            <summary>Allows Func of service to be resolved even without registered service.</summary>
        </member>
        <member name="M:DryIoc.Rules.WithFuncAndLazyWithoutRegistration">
            <summary>Allows Func of service to be resolved even without registered service.</summary>
        </member>
        <member name="P:DryIoc.Rules.UseFastExpressionCompiler">
            Commands to use FastExpressionCompiler - set by default.
        </member>
        <member name="M:DryIoc.Rules.WithoutFastExpressionCompiler">
            Fallbacks to system `Expression.Compile()`
        </member>
        <member name="P:DryIoc.Rules.UseInterpretationForTheFirstResolution">
            Subject-subject
        </member>
        <member name="M:DryIoc.Rules.WithoutInterpretationForTheFirstResolution">
            Fallbacks to system `Expression.Compile()`
        </member>
        <member name="M:DryIoc.Rules.ToString">
            <summary>Outputs most notable non-default rules</summary>
        </member>
        <member name="T:DryIoc.FactoryMethod">
            <summary>Wraps constructor or factory method optionally with factory instance to create service.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorOrMethodOrMember">
            <summary>Constructor or method to use for service creation.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.FactoryServiceInfo">
            <summary>Identifies factory service if factory method is instance member.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.FactoryExpression">
            Alternatively you may just provide an expression for factory
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo)">
            <summary>Wraps method and factory instance.
            Where <paramref name="ctorOrMethodOrMember"/> is constructor, static or instance method, property or field.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of(System.Reflection.MemberInfo,System.Object)">
            <summary>Wraps method and factory instance.
            Where <paramref name="methodOrMember"/> is constructor, static or instance method, property or field.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Of``1(System.String)">
            <summary>Discovers the static factory method or member by name in <typeparamref name="TFactory"/>.
            Should play nice with C# <see langword="nameof"/> operator.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.ToString">
            <summary>Pretty prints wrapped method.</summary>
        </member>
        <member name="M:DryIoc.FactoryMethod.Constructor(System.Boolean,System.Boolean)">
            <summary>Easy way to specify non-public and most resolvable constructor.</summary>
            <param name="mostResolvable">(optional) Instructs to select constructor with max number of params which all are resolvable.</param>
            <param name="includeNonPublic">(optional) Consider the non-public constructors.</param>
            <returns>Constructor or null if not found.</returns>
        </member>
        <member name="M:DryIoc.FactoryMethod.DefaultConstructor(System.Boolean)">
            <summary>Easy way to specify default constructor to be used for resolution.</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArguments">
            <summary>Searches for public constructor with most resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving service and Func{TArgs..., TService}</summary>
        </member>
        <member name="F:DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublic">
            <summary>Searches for constructor (including non public ones) with most
            resolvable parameters or throws <see cref="T:DryIoc.ContainerException"/> if not found.
            Works both for resolving service and Func{TArgs..., TService}</summary>
        </member>
        <member name="T:DryIoc.Made">
            <summary>Rules how to: <list type="bullet">
            <item>Select constructor for creating service with <see cref="P:DryIoc.Made.FactoryMethod"/>.</item>
            <item>Specify how to resolve constructor parameters with <see cref="P:DryIoc.Made.Parameters"/>.</item>
            <item>Specify what properties/fields to resolve and how with <see cref="P:DryIoc.Made.PropertiesAndFields"/>.</item>
            </list></summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethod">
            <summary>Returns delegate to select constructor based on provided request.</summary>
        </member>
        <member name="P:DryIoc.Made.FactoryMethodKnownResultType">
            <summary>Return type of strongly-typed factory method expression.</summary>
        </member>
        <member name="P:DryIoc.Made.HasCustomDependencyValue">
            <summary>True is made has properties or parameters with custom value.
            That's mean the whole made become context based which affects caching</summary>
        </member>
        <member name="F:DryIoc.Made.IsConditionalImplementation">
            <summary>Indicates that the implementation type depends on request.</summary>
        </member>
        <member name="P:DryIoc.Made.Parameters">
            <summary>Specifies how constructor parameters should be resolved:
            parameter service key and type, throw or return default value if parameter is unresolved.</summary>
        </member>
        <member name="P:DryIoc.Made.PropertiesAndFields">
            <summary>Specifies what <see cref="T:DryIoc.ServiceInfo"/> should be used when resolving property or field.</summary>
        </member>
        <member name="M:DryIoc.Made.ToString">
            <summary>Outputs whatever is possible (known) for Made</summary>
        </member>
        <member name="F:DryIoc.Made.Default">
            <summary>Container will use some sensible defaults for service creation.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.FactoryMethodSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.FactoryMethod"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.ParameterSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.Parameters"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.op_Implicit(DryIoc.PropertiesAndFieldsSelector)~DryIoc.Made">
            <summary>Creates rules with only <see cref="P:DryIoc.Made.PropertiesAndFields"/> specified.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethodSelector,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector,System.Boolean)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(DryIoc.FactoryMethod,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="F:DryIoc.Made.Default"/> rules.</summary>
            <param name="factoryMethod">Known factory method.</param>
            <param name="parameters">(optional)</param> <param name="propertiesAndFields">(optional)</param>
            <returns>New injection rules.</returns>
        </member>
        <member name="M:DryIoc.Made.Of(System.Reflection.MemberInfo,DryIoc.ServiceInfo,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory method specification</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},DryIoc.ServiceInfo,DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with method or member selector based on request.
            Where <paramref name="getMethodOrMember"/> is method, or constructor, or member selector.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Type},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with implementation type, conditionally depending on request.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{DryIoc.Request,System.Reflection.MemberInfo},System.Func{DryIoc.Request,DryIoc.ServiceInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Creates factory specification with method or member selector based on request.
            Where <paramref name="getMethodOrMember"/>Method, or constructor, or member selector.</summary>
        </member>
        <member name="M:DryIoc.Made.Of(System.Func{System.Type,System.Reflection.ConstructorInfo},DryIoc.ParameterSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Defines how to select constructor from implementation type.
            Where <paramref name="getConstructor"/> is delegate taking implementation type as input 
            and returning selected constructor info.</summary>
        </member>
        <member name="M:DryIoc.Made.Of``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Defines factory method using expression of constructor call (with properties), or static method call.</summary>
            <typeparam name="TService">Type with constructor or static method.</typeparam>
            <param name="serviceReturningExpr">Expression tree with call to constructor with properties:
            <code lang="cs"><![CDATA[() => new Car(Arg.Of<IEngine>()) { Color = Arg.Of<Color>("CarColor") }]]></code>
            or static method call <code lang="cs"><![CDATA[() => Car.Create(Arg.Of<IEngine>())]]></code></param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(System.Func{DryIoc.Request,DryIoc.ServiceInfo.Typed{``0}},System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.Request,System.Object}[])">
            <summary>Defines creation info from factory method call Expression without using strings.
            You can supply any/default arguments to factory method, they won't be used, it is only to find the <see cref="T:System.Reflection.MethodInfo"/>.</summary>
            <typeparam name="TFactory">Factory type.</typeparam> <typeparam name="TService">Factory product type.</typeparam>
            <param name="getFactoryInfo">Returns or resolves factory instance.</param>
            <param name="serviceReturningExpr">Method, property or field expression returning service.</param>
            <param name="argValues">(optional) Primitive custom values for dependencies.</param>
            <returns>New Made specification.</returns>
        </member>
        <member name="M:DryIoc.Made.Of``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{DryIoc.Request,System.Object}[])">
            Composes Made.Of expression with known factory instance and expression to get a service
        </member>
        <member name="T:DryIoc.Made.TypedMade`1">
            <summary>Typed version of <see cref="T:DryIoc.Made"/> specified with statically typed expression tree.</summary>
        </member>
        <member name="T:DryIoc.Arg">
            <summary>Class for defining parameters/properties/fields service info in <see cref="T:DryIoc.Made"/> expressions.
            Arg methods are NOT actually called, they just used to reflect service info from call expression.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1">
            <summary>Specifies required service type of parameter or member. If required type is the same as parameter/member type,
            the method is just a placeholder to help detect constructor or factory method, and does not have additional meaning.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(System.String,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(System.String,System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy. Plus specifies service key.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``2(DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies both service and required service types.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.Arg.Of``1(``0,DryIoc.IfUnresolved,System.Object)">
            <summary>Specifies required service type, default value and <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</summary>
        </member>
        <member name="M:DryIoc.Arg.Index``1(System.Int32)">
            <summary>Specifies argument index starting from 0 to use corresponding custom value factory,
            similar to String.Format <c>"{0}, {1}, etc"</c>.</summary>
        </member>
        <member name="F:DryIoc.Arg.ArgIndexMethodName">
            <summary>Name is close to method itself to not forget when renaming the method.</summary>
        </member>
        <member name="T:DryIoc.Registrator">
            <summary>Contains <see cref="T:DryIoc.IRegistrator"/> extension methods to simplify general use cases.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.Factory,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>The base method for registering servce with its implementation factory. Allows to specify all possible options.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register(DryIoc.IRegistrator,System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service of <paramref name="serviceAndMayBeImplementationType"/>.
            ServiceType may be the same as <paramref name="serviceAndMayBeImplementationType"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service of <typeparamref name="TService"/> type
            implemented by <typeparamref name="TImplementation"/> type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers implementation type <typeparamref name="TImplementation"/> with itself as service type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``2(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``1},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Register``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers service type returned by Made expression.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IRegistrator,System.Boolean,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            It is always back, bit now the roles are split, this just a normal registration to the root container,
            Look at `Use` method to put instance directly into Current Scope or Singletons Scope,
            though without ability to use decorators and wrappers on it.
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance(DryIoc.IRegistrator,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            It is always back, bit now the roles are split, this just a normal registration to the root container,
            Look at `Use` method to put instance directly into Current Scope or Singletons Scope,
            though without ability to use decorators and wrappers on it.
        </member>
        <member name="M:DryIoc.Registrator.RegisterInstance``1(DryIoc.IRegistrator,``0,System.Nullable{DryIoc.IfAlreadyRegistered},DryIoc.Setup,System.Object)">
            It is always back, bit now the roles are split, this just a normal registration to the root container,
            Look at `Use` method to put instance directly into Current Scope or Singletons Scope,
            though without ability to use decorators and wrappers on it.
        </member>
        <member name="F:DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes">
            <summary>List of types excluded by default from RegisterMany convention.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsExcludedGeneralPurposeServiceType(System.Type)">
            <summary>Checks that type is not in the list of <see cref="F:DryIoc.Registrator.ExcludedGeneralPurposeServiceTypes"/>.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsServiceType(System.Type)">
            <summary>Checks that type can be used a service type.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsImplementationType(System.Type)">
            <summary>Checks if type can be used as implementation type for reflection factory,
            and therefore registered to container. Usually used to discover implementation types from assembly.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns only those types that could be used as service types of <paramref name="type"/>.
            It means that for open-generic <paramref name="type"/> its service type should supply all type arguments.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetRegisterManyImplementedServiceTypes(System.Type,System.Boolean)">
            <summary>Returns the sensible services automatically discovered for RegisterMany implementation type.
            Excludes the collection wrapper interfaces. The <paramref name="type"/> may be concrete, abstract or
            generic definition.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementationTypes(System.Reflection.Assembly)">
            <summary>Returns the types suitable to be an implementation types for <see cref="T:DryIoc.ReflectionFactory"/>:
            actually a non abstract and not compiler generated classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.GetImplementationTypes(System.Reflection.Assembly,System.Func{System.Type,System.Boolean})">
            <summary>Returns the types suitable to be an implementation types for <see cref="T:DryIoc.ReflectionFactory"/>:
            actually a non abstract and not compiler generated classes.</summary>
        </member>
        <member name="F:DryIoc.Registrator.Interfaces">
            <summary>Sugar, so you can say <code lang="cs"><![CDATA[r.RegisterMany<X>(Registrator.Interfaces)]]></code></summary>
        </member>
        <member name="M:DryIoc.Registrator.ImplementsServiceType(System.Type,System.Type)">
            <summary>Checks if <paramref name="type"/> implements a service type,
            along the checking if <paramref name="type"/> and service type
            are valid implementation and service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ImplementsServiceType``1(System.Type)">
            <summary>Checks if <paramref name="type"/> implements a service type,
            along the checking if <paramref name="type"/> and service type
            are valid implementation and service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ToFactory(System.Type)">
            <summary>Wraps the implementation type in factory.</summary>
        </member>
        <member name="M:DryIoc.Registrator.ToFactory(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Wraps the implementation type in factory plus allow to provide factory parameters.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},System.Func{System.Type,System.Type[]},System.Func{System.Type,DryIoc.Factory},System.Func{System.Type,System.Type,System.Object},System.Nullable{DryIoc.IfAlreadyRegistered})">
            <summary>A primary (basic) method for batch registering of implementations with possibly many service types.
            The default factory is the <see cref="T:DryIoc.ReflectionFactory"/> with default reuse.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Type[],System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Batch registers implementation with possibly many service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Type[]},System.Func{System.Type,DryIoc.Factory},System.Func{System.Type,System.Type,System.Object},System.Nullable{DryIoc.IfAlreadyRegistered})">
            <summary>Batch registers assemblies of implementation types with possibly many service types.
            The default factory is the <see cref="T:DryIoc.ReflectionFactory"/> with default reuse.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Func{System.Type,System.Boolean},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean,System.Object)">
            <summary>Registers many implementations with their auto-figured service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany(DryIoc.IRegistrator,System.Collections.Generic.IEnumerable{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers many implementations with auto-figured service types.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMany``1(DryIoc.IRegistrator,DryIoc.Made.TypedMade{``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Func{System.Type,System.Boolean},System.Boolean,System.Object)">
            <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,``0},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers a factory delegate for creating an instance of <typeparamref name="TService"/>.
            Delegate can use resolver context parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <remarks>The alternative to this method please consider using <see cref="T:DryIoc.Made"/> instead:
            <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>.
            </remarks>
        </member>
        <member name="M:DryIoc.Registrator.ToFactoryDelegate``1(System.Func{DryIoc.IResolverContext,``0},DryIoc.IResolverContext)">
            Minimizes the number of allocations when converting from Func to named delegate
        </member>
        <member name="M:DryIoc.Registrator.ToFactoryDelegate(System.Object,DryIoc.IResolverContext)">
            Lifts value to the factory delegate without allocations on capturing value in lambda closure
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Type,System.Func{DryIoc.IResolverContext,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Registers a factory delegate for creating an instance of <paramref name="serviceType"/>.
            Delegate can use resolver context parameter to resolve any required dependencies, e.g.:
            <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
            <remarks>IMPORTANT: The method should be used as the last resort only! Though powerful it is a black-box for container,
            which prevents diagnostics, plus it is easy to get memory leaks (due variables captured in delegate closure),
            and impossible to use in compile-time scenarios.
            Consider using <see cref="T:DryIoc.Made"/> instead:
            <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegate(DryIoc.IRegistrator,System.Boolean,System.Type,System.Func{DryIoc.IResolverContext,System.Object},DryIoc.IReuse,DryIoc.Setup,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            A special performant version mostly for integration with other libraries,
            that already check compatiblity between delegate result and the service type
        </member>
        <member name="M:DryIoc.Registrator.RegisterDelegateDecorator``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,System.Func{``0,``0}},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Registers decorator function that gets decorated value as input and returns decorator.
            Note: Delegate decorator will use <see cref="T:DryIoc.Reuse"/> of decoratee service.</summary>
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IResolverContext,``0,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IRegistrator,``0,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IContainer,``0,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IResolverContext,System.Type,System.Object,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IRegistrator,System.Type,System.Object,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IContainer,System.Type,System.Object,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance``1(DryIoc.IResolverContext,``0,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IResolverContext,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.UseInstance(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Will become OBSOLETE! in the next major version:
            Please use `RegisterInstance` or `Use` method instead.
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IResolverContext,System.Func{DryIoc.IResolverContext,``0})">
            Adding the factory directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IResolverContext,System.Type,System.Object)">
            Adding the instance directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IResolverContext,``0)">
            Adding the instance directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IRegistrator,System.Func{DryIoc.IResolverContext,``0})">
            Adding the factory directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IRegistrator,System.Type,System.Object)">
            Adding the instance directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IRegistrator,``0)">
            Adding the instance directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IContainer,System.Func{DryIoc.IResolverContext,``0})">
            Adding the factory directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.Use(DryIoc.IContainer,System.Type,System.Object)">
            Adding the instance directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.Use``1(DryIoc.IContainer,``0)">
            Adding the instance directly to scope for resolution 
        </member>
        <member name="M:DryIoc.Registrator.RegisterInitializer``1(DryIoc.IRegistrator,System.Action{``0,DryIoc.IResolverContext},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Registers initializing action that will be called after service is resolved 
            just before returning it to the caller.  You can register multiple initializers for single service.
            Or you can register initializer for <see cref="T:System.Object"/> type to be applied 
            for all services and use <paramref name="condition"/> to specify the target services.</summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterDisposer``1(DryIoc.IRegistrator,System.Action{``0},System.Func{DryIoc.Request,System.Boolean})">
            <summary>Registers dispose action for reused target service.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <paramref name="serviceType"/> is registered in container OR
            its open generic definition is registered in container.
            The additional implementation factory <paramref name="condition"/> may be specified to narrow the search.</summary>
        </member>
        <member name="M:DryIoc.Registrator.IsRegistered``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if <typeparamref name="TService"/> is registered in container OR
            its open generic definition is registered in container.
            The additional implementation factory <paramref name="condition"/> may be specified to narrow the search.</summary>
        </member>
        <member name="M:DryIoc.Registrator.Unregister(DryIoc.IRegistrator,System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.
            It also tries to remove the cached resolutions for the removed registration, But it may not work depending on context.
            Check the docs for more info: https://bitbucket.org/dadhi/dryioc/wiki/UnregisterAndResolutionCache </summary>
        </member>
        <member name="M:DryIoc.Registrator.Unregister``1(DryIoc.IRegistrator,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes specified registration from container.
            It also tries to remove the cached resolutions for the removed registration, But it may not work depending on context.
            Check the docs for more info: https://bitbucket.org/dadhi/dryioc/wiki/UnregisterAndResolutionCache </summary>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping(DryIoc.IRegistrator,System.Type,System.Type,System.Object,System.Object,DryIoc.FactoryType)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="registrator">Registrator</param> <param name="serviceType">New service type.</param>
            <param name="registeredServiceType">Existing registered service type.</param>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <param name="factoryType">(optional) By default is <see cref="F:DryIoc.FactoryType.Service"/></param>
            <remarks>Does nothing if registration is already exists.</remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterMapping``2(DryIoc.IRegistrator,System.Object,System.Object,DryIoc.FactoryType)">
            <summary>Registers new service type with factory for registered service type.
            Throw if no such registered service type in container.</summary>
            <param name="registrator">Registrator</param>
            <typeparam name="TService">New service type.</typeparam>
            <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
            <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
            <param name="factoryType">(optional) By default is <see cref="F:DryIoc.FactoryType.Service"/></param>
            <remarks>Does nothing if registration is already exists.</remarks>
        </member>
        <member name="M:DryIoc.Registrator.RegisterPlaceholder(DryIoc.IRegistrator,System.Type,System.Nullable{DryIoc.IfAlreadyRegistered},System.Object)">
            <summary>Register a service without implementation which can be provided later in terms
            of normal registration with IfAlreadyRegistered.Replace parameter.
            When the implementation is still not provided when the placeholder service is accessed,
            then the exception will be thrown.
            This feature allows you to postpone decision on implementation until it is later known.</summary>
            <remarks>Internally the empty factory is registered with the setup asResolutionCall set to true.
            That means, instead of placing service instance into graph expression we put here redirecting call to
            container Resolve.</remarks>
        </member>
        <member name="T:DryIoc.Resolver">
            <summary>Extension methods for <see cref="T:DryIoc.IResolver"/>.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type)">
            <summary>Resolves instance of service type from container. Throws exception if unable to resolve.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved)">
            <summary>Resolves instance of service type from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,DryIoc.IfUnresolved)">
            <summary>Resolves instance of type TService from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Boolean)">
            <summary>Tries to resolve instance of service type from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Boolean)">
            <summary>Tries to resolve instance of TService from container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Type,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <paramref name="requiredServiceType"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(IEnumerable<object>), typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Type,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <paramref name="requiredServiceType"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <paramref name="requiredServiceType"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>>(typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``2(DryIoc.IResolver,DryIoc.IfUnresolved,System.Object[],System.Object)">
            <summary>Returns instance of <typeparamref name="TService"/> searching for <typeparamref name="TRequiredService"/>.
            In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
            <typeparamref name="TRequiredService"/> allow you to specify wrapped service type.</summary>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve<IEnumerable<object>, IService>();
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,System.Object[])">
            <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
            In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
            could specify wrapped service type.</summary>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
            <example><code lang="cs"><![CDATA[
                container.Register<IService, Service>();
                var services = container.Resolve(typeof(Lazy<object>), "someKey", requiredServiceType: typeof(IService));
            ]]></code></example>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object,DryIoc.IfUnresolved,System.Type,System.Object[])">
            <summary>Returns instance of <typepsaramref name="TService"/> type.</summary>
            <typeparam name="TService">The type of the requested service.</typeparam>
            <returns>The requested service instance.</returns>
            <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
        </member>
        <member name="M:DryIoc.Resolver.Resolve(DryIoc.IResolver,System.Type,System.Object[],DryIoc.IfUnresolved,System.Type,System.Object)">
            <summary>Resolves the service supplying all or some of its dependencies 
            (including nested) with the <paramref name="args"/>. The rest of dependencies is injected from
            container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.Resolve``1(DryIoc.IResolver,System.Object[],DryIoc.IfUnresolved,System.Type,System.Object)">
            <summary>Resolves the service supplying all or some of its dependencies 
            (including nested) with the <paramref name="args"/>. The rest of dependencies is injected from
            container.</summary>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)">
            <summary>Returns all registered services instances including all keyed and default registrations.
            Use <paramref name="behavior"/> to return either all registered services at the moment of resolve (dynamic fresh view) or
            the same services that were returned with first <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)"/> call (fixed view).</summary>
            <typeparam name="TService">Return collection item type. 
            It denotes registered service type if <paramref name="requiredServiceType"/> is not specified.</typeparam>
            <remarks>The same result could be achieved by directly calling:
            <code lang="cs"><![CDATA[
                container.Resolve<LazyEnumerable<IService>>();  // for dynamic result - default behavior
                container.Resolve<IService[]>();                // for fixed array
                container.Resolve<IEnumerable<IService>>();     // same as fixed array
            ]]></code>
            </remarks>
        </member>
        <member name="M:DryIoc.Resolver.ResolveMany(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)">
            <summary>Returns all registered services as objects, including all keyed and default registrations.</summary>
        </member>
        <member name="T:DryIoc.ResolveManyBehavior">
            <summary>Specifies result of <see cref="M:DryIoc.Resolver.ResolveMany``1(DryIoc.IResolver,System.Type,DryIoc.ResolveManyBehavior,System.Object[],System.Object)"/>: either dynamic(lazy) or fixed view.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsLazyEnumerable">
            <summary>Lazy/dynamic item resolve.</summary>
        </member>
        <member name="F:DryIoc.ResolveManyBehavior.AsFixedArray">
            <summary>Fixed array of item at time of resolve, newly registered/removed services won't be listed.</summary>
        </member>
        <member name="T:DryIoc.IServiceInfo">
            <summary>Provides information required for service resolution: service type
            and optional <see cref="T:DryIoc.ServiceDetails"/></summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.ServiceType">
            <summary>The required piece of info: service type.</summary>
        </member>
        <member name="P:DryIoc.IServiceInfo.Details">
            <summary>Additional optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="M:DryIoc.IServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="T:DryIoc.ServiceDetails">
            <summary>Provides optional service resolution details: service key, required service type, what return when service is unresolved,
            default value if service is unresolved, custom service value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Default">
            Default details if not specified, use default setting values, e.g. <see cref="F:DryIoc.IfUnresolved.Throw"/>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefault">
            Default details with <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> option.
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolvedReturnDefaultIfNotRegistered">
            Default details with <see cref="F:DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered"/> option.
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates new details out of provided settings, or returns default if all settings have default value.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.Of(System.Object)">
            <summary>Sets custom value for service. This setting is orthogonal to the rest.
            Using default value with invalid ifUnresolved.Throw option to indicate custom value.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.RequiredServiceType">
            <summary>Service type to search in registry. Should be assignable to user requested service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.ServiceKey">
            <summary>Service key provided with registration.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.MetadataKey">
            <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.Metadata">
            <summary>Metadata value to find in resolved service.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.IfUnresolved">
            <summary>Policy to deal with unresolved request.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails.HasCustomValue">
            <summary>Indicates that the custom value is specified.</summary>
        </member>
        <member name="F:DryIoc.ServiceDetails._value">
            <summary>Either default or custom value depending on <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> setting.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.DefaultValue">
            <summary>Value to use in case <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is set to not Throw.</summary>
        </member>
        <member name="P:DryIoc.ServiceDetails.CustomValue">
            <summary>Custom value specified for dependency. The IfUnresolved.Throw is the marker of custom value comparing to default value.</summary>
        </member>
        <member name="M:DryIoc.ServiceDetails.ToString">
            <summary>Pretty prints service details to string for debugging and errors.</summary> <returns>Details string.</returns>
        </member>
        <member name="T:DryIoc.ServiceInfoTools">
            <summary>Contains tools for combining or propagating of <see cref="T:DryIoc.IServiceInfo"/> independent of its concrete implementations.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.With(DryIoc.IServiceInfo,System.Type)">
            <summary>Creates service info with new type but keeping the details.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithIfUnresolved(DryIoc.IServiceInfo,DryIoc.IfUnresolved)">
            <summary>Creates new info with new IfUnresolved behavior or returns the original info if behavior is not different,
            or the passed info is not a <see cref="F:DryIoc.ServiceDetails.HasCustomValue"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.WithDetails``1(``0,DryIoc.ServiceDetails)">
            <summary>Combines service info with details. The main goal is to combine service and required service type.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.InheritInfoFromDependencyOwner(DryIoc.IServiceInfo,DryIoc.IServiceInfo,DryIoc.IContainer,DryIoc.FactoryType)">
            <summary>Enables propagation/inheritance of info between dependency and its owner:
            for instance <see cref="F:DryIoc.ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.GetActualServiceType(DryIoc.IServiceInfo)">
            <summary>Returns required service type if it is specified and assignable to service type,
            otherwise returns service type.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)">
            <summary>Appends info string representation into provided builder.</summary>
        </member>
        <member name="T:DryIoc.ServiceInfo">
            <summary>Represents custom or resolution root service info, there is separate representation for parameter,
            property and field dependencies.</summary>
        </member>
        <member name="F:DryIoc.ServiceInfo.Empty">
            <summary>Empty service info for convenience.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,DryIoc.IfUnresolved,System.Object)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of(System.Type,System.Type,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Creates info out of provided settings</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Of``1(DryIoc.IfUnresolved,System.Object)">
            <summary>Creates service info using typed <typeparamref name="TService"/>.</summary>
        </member>
        <member name="T:DryIoc.ServiceInfo.Typed`1">
            <summary>Strongly-typed version of Service Info.</summary> <typeparam name="TService">Service type.</typeparam>
        </member>
        <member name="M:DryIoc.ServiceInfo.Typed`1.#ctor">
            <summary>Creates service info object.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceType">
            <summary>Type of service to create. Indicates registered service in registry.</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.ServiceKey">
            <summary>Shortcut access to service key</summary>
        </member>
        <member name="P:DryIoc.ServiceInfo.Details">
            <summary>Additional settings. If not specified uses <see cref="F:DryIoc.ServiceDetails.Default"/>.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="M:DryIoc.ServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.ParameterServiceInfo">
            <summary>Provides <see cref="T:DryIoc.IServiceInfo"/> for parameter,
            by default using parameter name as <see cref="P:DryIoc.IServiceInfo.ServiceType"/>.</summary>
            <remarks>For parameter default setting <see cref="F:DryIoc.ServiceDetails.IfUnresolved"/> is <see cref="F:DryIoc.IfUnresolved.Throw"/>.</remarks>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Of(System.Reflection.ParameterInfo)">
            <summary>Creates service info from parameter alone, setting service type to parameter type,
            and setting resolution policy to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/> if parameter is optional.</summary>
            <param name="parameter">Parameter to create info for.</param>
            <returns>Parameter service info.</returns>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.ServiceType">
            <summary>Service type specified by <see cref="P:System.Reflection.ParameterInfo.ParameterType"/>.</summary>
        </member>
        <member name="P:DryIoc.ParameterServiceInfo.Details">
            <summary>Optional service details.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
        </member>
        <member name="F:DryIoc.ParameterServiceInfo.Parameter">
            <summary>Parameter info.</summary>
        </member>
        <member name="M:DryIoc.ParameterServiceInfo.ToString">
            <summary>Prints info to string using <see cref="M:DryIoc.ServiceInfoTools.Print(System.Text.StringBuilder,DryIoc.IServiceInfo)"/>.</summary> <returns>Printed string.</returns>
        </member>
        <member name="T:DryIoc.PropertyOrFieldServiceInfo">
            <summary>Base class for property and field dependency info.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Of(System.Reflection.MemberInfo)">
            <summary>Create member info out of provide property or field.</summary>
            <param name="member">Member is either property or field.</param> <returns>Created info.</returns>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.ServiceType">
            <summary>The required service type. It will be either <see cref="P:System.Reflection.FieldInfo.FieldType"/> or <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>.</summary>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Details">
            <summary>Optional details: service key, if-unresolved policy, required service type.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.Create(System.Type,DryIoc.ServiceDetails)">
            <summary>Creates info from service type and details.</summary>
            <param name="serviceType">Required service type.</param> <param name="details">Optional details.</param> <returns>Create info.</returns>
        </member>
        <member name="P:DryIoc.PropertyOrFieldServiceInfo.Member">
            <summary>Either <see cref="T:System.Reflection.PropertyInfo"/> or <see cref="T:System.Reflection.FieldInfo"/>.</summary>
        </member>
        <member name="M:DryIoc.PropertyOrFieldServiceInfo.SetValue(System.Object,System.Object)">
            <summary>Sets property or field value on provided holder object.</summary>
            <param name="holder">Holder of property or field.</param> <param name="value">Value to set.</param>
        </member>
        <member name="T:DryIoc.RequestFlags">
            <summary>Stored check results of two kinds: inherited down dependency chain and not.</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.TracksTransientDisposable">
            <summary>Not inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsSingletonOrDependencyOfSingleton">
            <summary>Inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsWrappedInFunc">
            <summary>Inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsResolutionCall">
            <summary>Indicates that the request is the one from Resolve call.</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.OpensResolutionScope">
            <summary>Non inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.StopRecursiveDependencyCheck">
            <summary>Non inherited</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsGeneratedResolutionDependencyExpression">
            <summary>Non inherited. Marks the expression to be added to generated resolutions to prevent infinite recursion</summary>
        </member>
        <member name="F:DryIoc.RequestFlags.IsDirectlyWrappedInFunc">
            <summary>Non inherited. Indicates the root service inside the function.</summary>
        </member>
        <member name="T:DryIoc.RequestTools">
            Helper extension methods to use on the bunch of factories instead of lambdas to minimize allocations
        </member>
        <member name="T:DryIoc.Request">
            <summary>Tracks the requested service and resolved factory details in a chain of nested dependencies.</summary>
        </member>
        <member name="F:DryIoc.Request.Empty">
            <summary>Empty terminal request.</summary>
        </member>
        <member name="F:DryIoc.Request.EmptyOpensResolutionScope">
            <summary>Empty request which opens resolution scope.</summary>
        </member>
        <member name="M:DryIoc.Request.Create(DryIoc.IContainer,DryIoc.IServiceInfo,DryIoc.Request,DryIoc.RequestFlags,System.Object[])">
            <summary>Creates the Resolve request. The container initiated the Resolve is stored with request.</summary>
        </member>
        <member name="M:DryIoc.Request.Create(DryIoc.IContainer,System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.Request,DryIoc.RequestFlags,System.Object[])">
            <summary>Creates the Resolve request. The container initiated the Resolve is stored with request.</summary>
        </member>
        <member name="F:DryIoc.Request.Container">
            <summary>Available in runtime only, provides access to container initiated request.</summary>
        </member>
        <member name="F:DryIoc.Request.DirectParent">
            <summary>Request immediate parent.</summary>
        </member>
        <member name="F:DryIoc.Request.Flags">
            <summary>Persisted request conditions</summary>
        </member>
        <member name="F:DryIoc.Request._serviceInfo">
            mutable, so that the ServiceKey or IfUnresolved can be changed in place.
        </member>
        <member name="F:DryIoc.Request.InputArgExprs">
            <summary>Input arguments provided with `Resolve`</summary>
        </member>
        <member name="F:DryIoc.Request.Factory">
            <summary>Runtime known resolve factory, otherwise is <c>null</c></summary>
        </member>
        <member name="P:DryIoc.Request.FactoryID">
            <summary>Resolved factory ID, used to identify applied decorator.</summary>
        </member>
        <member name="P:DryIoc.Request.FactoryType">
            <summary>Type of factory: Service, Wrapper, or Decorator.</summary>
        </member>
        <member name="P:DryIoc.Request.ImplementationType">
            <summary>Service implementation type if known.</summary>
        </member>
        <member name="P:DryIoc.Request.Reuse">
            <summary>Service reuse.</summary>
        </member>
        <member name="P:DryIoc.Request.DecoratedFactoryID">
            <summary>ID of decorated factory in case of decorator factory type</summary>
        </member>
        <member name="F:DryIoc.Request.DependencyDepth">
            <summary>Number of nested dependencies. Set with each new Push.</summary>
        </member>
        <member name="F:DryIoc.Request.ExprCache">
            Holds the resolved expressions
        </member>
        <member name="P:DryIoc.Request.IsEmpty">
            <summary>Indicates that request is empty initial request.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionRoot">
            <summary>Returns true if request is First in First Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.IsResolutionCall">
            <summary>Returns true if request is First in Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Request.IsNestedResolutionCall">
            <summary>Not the root resolution call.</summary>
        </member>
        <member name="P:DryIoc.Request.OpensResolutionScope">
            <summary>Returns true if request is First in First Resolve call.</summary>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFunc">
            <summary>Checks if the request Or its parent is wrapped in Func.
            Use <see cref="M:DryIoc.Request.IsDirectlyWrappedInFunc"/> for the direct Func wrapper.</summary>
        </member>
        <member name="M:DryIoc.Request.IsDirectlyWrappedInFunc">
            <summary>Checks if the request is directly wrapped in Func</summary>
        </member>
        <member name="M:DryIoc.Request.IsWrappedInFuncWithArgs">
            <summary>Checks if request has parent with service type of Func with arguments.</summary>
        </member>
        <member name="M:DryIoc.Request.GetInputArgsExpr">
            <summary>Returns expression for func arguments.</summary>
        </member>
        <member name="P:DryIoc.Request.TracksTransientDisposable">
            <summary>Indicates that requested service is transient disposable that should be tracked.</summary>
        </member>
        <member name="P:DryIoc.Request.IsSingletonOrDependencyOfSingleton">
            <summary>Indicates the request is singleton or has singleton upper in dependency chain.</summary>
        </member>
        <member name="M:DryIoc.Request.ShouldSplitObjectGraph">
            <summary>Returns true if object graph should be split due <see cref="P:DryIoc.Rules.DependencyDepthToSplitObjectGraph"/> setting.</summary>
        </member>
        <member name="P:DryIoc.Request.CurrentScope">
            <summary>Current scope</summary>
        </member>
        <member name="P:DryIoc.Request.SingletonScope">
            <summary>Singletons</summary>
        </member>
        <member name="P:DryIoc.Request.Rules">
            <summary>Shortcut to issued container rules.</summary>
        </member>
        <member name="P:DryIoc.Request.Made">
            <summary>(optional) Made spec used for resolving request.</summary>
        </member>
        <member name="P:DryIoc.Request.Parent">
            <summary>Returns service parent skipping wrapper if any. To get direct parent use <see cref="F:DryIoc.Request.DirectParent"/>.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceType">
            <summary>Requested service type.</summary>
        </member>
        <member name="M:DryIoc.Request.GetActualServiceType">
            <summary>Compatible required or service type.</summary>
        </member>
        <member name="P:DryIoc.Request.ServiceKey">
            <summary>Optional service key to identify service of the same type.</summary>
        </member>
        <member name="P:DryIoc.Request.MetadataKey">
            <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.Metadata">
            <summary>Metadata or the value (if key specified) to find in resolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.IfUnresolved">
            <summary>Policy to deal with unresolved service.</summary>
        </member>
        <member name="P:DryIoc.Request.RequiredServiceType">
            <summary>Required service type if specified.</summary>
        </member>
        <member name="P:DryIoc.Request.ReuseLifespan">
            <summary>Relative number representing reuse lifespan.</summary>
        </member>
        <member name="M:DryIoc.Request.GetKnownImplementationOrServiceType">
            <summary>Known implementation, or otherwise actual service type.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(DryIoc.IServiceInfo,DryIoc.RequestFlags)">
            <summary>Creates new request with provided info, and links current request as a parent.
            Allows to set some additional flags. Existing/parent request should be resolved to 
            factory via `WithResolvedFactory` before pushing info into it.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.RequestFlags)">
            <summary>Composes service description into <see cref="T:DryIoc.IServiceInfo"/> and Pushes the new request.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Int32,System.Type,DryIoc.IReuse)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags,System.Int32)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.Push(System.Type,System.Type,System.Object,System.String,System.Object,DryIoc.IfUnresolved,System.Int32,DryIoc.FactoryType,System.Type,DryIoc.IReuse,DryIoc.RequestFlags,System.Int32)">
            <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
        </member>
        <member name="M:DryIoc.Request.WithChangedServiceInfo(System.Func{DryIoc.IServiceInfo,DryIoc.IServiceInfo})">
            <summary>Allow to switch current service info to the new one, e.g. in decorators.
            If info did not change then return the same this request.</summary>
        </member>
        <member name="M:DryIoc.Request.WithIfUnresolved(DryIoc.IfUnresolved)">
            Produces the new request with the changed `ifUnresolved` or returns original request otherwise
        </member>
        <member name="M:DryIoc.Request.WithFlags(DryIoc.RequestFlags)">
            <summary>Updates the flags</summary>
        </member>
        <member name="M:DryIoc.Request.ChangeServiceKey(System.Object)">
            <summary>Sets service key to passed value. Required for multiple default services to change null key to
            actual <see cref="T:DryIoc.DefaultKey"/></summary>
        </member>
        <member name="M:DryIoc.Request.WithInputArgs(FastExpressionCompiler.LightExpression.Expression[])">
            <summary>Prepends input arguments to existing arguments in request. It is done because the
            nested Func/Action input argument has a priority over outer argument.
            The arguments are provided by Func and Action wrappers, or by `args` parameter in Resolve call.</summary>
        </member>
        <member name="M:DryIoc.Request.WithResolvedFactory(DryIoc.Factory,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Returns new request with set implementation details.</summary>
            <param name="factory">Factory to which request is resolved.</param>
            <param name="skipRecursiveDependencyCheck">(optional) does not check for recursive dependency.
            Use with caution. Make sense for Resolution expression.</param>
            <param name="skipCaptiveDependencyCheck">(optional) allows to skip reuse mismatch aka captive dependency check.</param>
            <param name="copyRequest">Make a defensive copy of request.</param>
            <returns>New request with set factory.</returns>
        </member>
        <member name="M:DryIoc.Request.HasRecursiveParent(System.Int32)">
            <summary>Check for the parents.</summary>
        </member>
        <member name="M:DryIoc.Request.Is``1(System.Func{``0},System.Func{System.Reflection.ParameterInfo,``0},System.Func{System.Reflection.PropertyInfo,``0},System.Func{System.Reflection.FieldInfo,``0})">
            <summary>If request corresponds to dependency injected into parameter,
            then method calls <paramref name="parameter"/> handling and returns its result.
            If request corresponds to property or field, then method calls respective handler.
            If request does not correspond to dependency, then calls <paramref name="root"/> handler.</summary>
        </member>
        <member name="M:DryIoc.Request.Enumerate">
            <summary>Obsolete: now request is directly implements the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:DryIoc.Request.GetEnumerator">
            <summary>Enumerates self and all request stack parents.</summary>
        </member>
        <member name="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)">
            <summary>Prints current request info only (no parents printed) to provided builder.</summary>
        </member>
        <member name="M:DryIoc.Request.Print(System.Int32)">
            <summary>Prints full stack of requests starting from current one using <see cref="M:DryIoc.Request.PrintCurrent(System.Text.StringBuilder)"/>.</summary>
        </member>
        <member name="M:DryIoc.Request.GetParentWithExprCache">
            <summary>Built expressions stored in resolution root (call).</summary>
        </member>
        <member name="M:DryIoc.Request.ToString">
            <summary>Prints whole request chain.</summary>
        </member>
        <member name="M:DryIoc.Request.Equals(System.Object)">
            <summary>Returns true if request info and passed object are equal, and their parents recursively are equal.</summary>
        </member>
        <member name="M:DryIoc.Request.Equals(DryIoc.Request)">
            <summary>Returns true if request info and passed info are equal, and their parents recursively are equal.</summary>
        </member>
        <member name="M:DryIoc.Request.EqualsWithoutParent(DryIoc.Request)">
            <summary>Compares self properties but not the parents.</summary>
        </member>
        <member name="M:DryIoc.Request.GetHashCode">
            <summary>Calculates the combined hash code based on factory IDs.</summary>
        </member>
        <member name="T:DryIoc.FactoryType">
            <summary>Type of services supported by Container.</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Service">
            <summary>(default) Defines normal service factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Decorator">
            <summary>Defines decorator factory</summary>
        </member>
        <member name="F:DryIoc.FactoryType.Wrapper">
            <summary>Defines wrapper factory.</summary>
        </member>
        <member name="T:DryIoc.Setup">
            <summary>Base class to store optional <see cref="T:DryIoc.Factory"/> settings.</summary>
        </member>
        <member name="P:DryIoc.Setup.FactoryType">
            <summary>Factory type is required to be specified by concrete setups as in
            <see cref="T:DryIoc.Setup.ServiceSetup"/>, <see cref="T:DryIoc.Setup.DecoratorSetup"/>, <see cref="T:DryIoc.Setup.WrapperSetup"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.Condition">
            <summary>Predicate to check if factory could be used for resolved request.</summary>
        </member>
        <member name="P:DryIoc.Setup.DisposalOrder">
            <summary>Relative disposal order when defined. Greater number, later dispose.</summary>
        </member>
        <member name="P:DryIoc.Setup.Metadata">
            <summary>Arbitrary metadata object associated with Factory/Implementation, may be a dictionary of key-values.</summary>
        </member>
        <member name="M:DryIoc.Setup.MatchesMetadata(System.String,System.Object)">
            <summary>Returns true if passed meta key and value match the setup metadata.</summary>
        </member>
        <member name="P:DryIoc.Setup.AsResolutionCall">
            <summary>Indicates that injected expression should be:
            <c><![CDATA[r.Resolver.Resolve<IDependency>(...)]]></c>
            instead of: <c><![CDATA[new Dependency(...)]]></c></summary>
        </member>
        <member name="F:DryIoc.Setup.AsResolutionCallSetup">
            Setup with the only setting: `AsResolutionCall` 
        </member>
        <member name="P:DryIoc.Setup.AsResolutionCallForExpressionGeneration">
            Works `AsResolutionCall` only with `Rules.UsedForExpressionGeneration`
        </member>
        <member name="F:DryIoc.Setup.AsResolutionCallForGeneratedExpressionSetup">
            Specifies to use `asResolutionCall` but only in expression generation context, e.g. DryIocZero
        </member>
        <member name="P:DryIoc.Setup.AsResolutionRoot">
            <summary>Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</summary>
        </member>
        <member name="P:DryIoc.Setup.OpenResolutionScope">
            <summary>Opens scope, also implies <see cref="P:DryIoc.Setup.AsResolutionCall"/>.</summary>
        </member>
        <member name="P:DryIoc.Setup.WeaklyReferenced">
            <summary>Stores reused instance as WeakReference.</summary>
        </member>
        <member name="P:DryIoc.Setup.AllowDisposableTransient">
            <summary>Allows registering transient disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.TrackDisposableTransient">
            <summary>Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</summary>
        </member>
        <member name="P:DryIoc.Setup.UseParentReuse">
            <summary>Instructs to use parent reuse. Applied only if <see cref="P:DryIoc.Factory.Reuse"/> is not specified.</summary>
        </member>
        <member name="P:DryIoc.Setup.PreventDisposal">
            <summary>Prevents disposal of reused instance if it is disposable.</summary>
        </member>
        <member name="P:DryIoc.Setup.PreferInSingleServiceResolve">
            <summary>When single service is resolved, but multiple candidates found, this options will be used to prefer this one.</summary>
        </member>
        <member name="F:DryIoc.Setup.Default">
            <summary>Default setup for service factories.</summary>
        </member>
        <member name="M:DryIoc.Setup.With(System.Object,System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>Constructs setup object out of specified settings.
            If all settings are default then <see cref="F:DryIoc.Setup.Default"/> setup will be returned.
            <paramref name="metadataOrFuncOfMetadata"/> is metadata object or Func returning metadata object.</summary>
        </member>
        <member name="F:DryIoc.Setup.Wrapper">
            <summary>Default setup which will look for wrapped service type as single generic parameter.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperWith(System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Func{DryIoc.Request,System.Boolean},System.Int32)">
            <summary>Returns generic wrapper setup.
            Default for <paramref name="wrappedServiceTypeArgIndex" /> is -1 for generic wrapper with single type argument.
            Index need to be set for multiple type arguments. <paramref name="alwaysWrapsRequiredServiceType" /> need to be set 
            when generic wrapper type arguments should be ignored.</summary>
        </member>
        <member name="F:DryIoc.Setup.Decorator">
            <summary>Default decorator setup: decorator is applied to service type it registered with.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorWith(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Creates setup with optional condition.
            The <paramref name="order" /> specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</summary>
        </member>
        <member name="M:DryIoc.Setup.GetDecorateeCondition(System.Type,System.Object,System.Func{DryIoc.Request,System.Boolean})">
            Creates a condition for both <paramref name="decorateeType"/>, <paramref name="decorateeServiceKey"/> and additional condition
        </member>
        <member name="M:DryIoc.Setup.DecoratorOf(System.Type,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Object)">
            <summary>Setup for decorator of type <paramref name="decorateeType"/>.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorOf``1(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Object)">
            <summary>Setup for decorator of type <typeparamref name="TDecoratee"/>.</summary>
        </member>
        <member name="T:DryIoc.Setup.ServiceSetup">
            <summary>Service setup.</summary>
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.FactoryType">
            <inheritdoc />
        </member>
        <member name="P:DryIoc.Setup.ServiceSetup.Metadata">
            <summary>Evaluates metadata if it specified as Func of object, and replaces Func with its result!.
            Otherwise just returns metadata object.</summary>
            <remarks>Invocation of Func metadata is Not thread-safe. Please take care of that inside the Func.</remarks>
        </member>
        <member name="M:DryIoc.Setup.ServiceSetup.#ctor">
            All settings are set to defaults.
        </member>
        <member name="M:DryIoc.Setup.ServiceSetup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Object,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            Specify all the individual settings.
        </member>
        <member name="T:DryIoc.Setup.WrapperSetup">
            <summary>Setup applied for wrappers.</summary>
        </member>
        <member name="P:DryIoc.Setup.WrapperSetup.FactoryType">
            <summary>Returns <see cref="F:DryIoc.FactoryType.Wrapper"/> type.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.WrappedServiceTypeArgIndex">
            <summary>Delegate to get wrapped type from provided wrapper type.
            If wrapper is generic, then wrapped type is usually a generic parameter.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.AlwaysWrapsRequiredServiceType">
            <summary>Per name.</summary>
        </member>
        <member name="F:DryIoc.Setup.WrapperSetup.Unwrap">
            <summary>Delegate returning wrapped type from wrapper type. Overwrites other options.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32)">
            <summary>Default setup</summary>
            <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument.
            Need to be set for multiple type arguments.</param>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.#ctor(System.Int32,System.Boolean,System.Func{System.Type,System.Type},System.Func{DryIoc.Request,System.Boolean},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Returns generic wrapper setup.
            Default for <paramref name="wrappedServiceTypeArgIndex" /> is -1 for generic wrapper with single type argument.
            Index need to be set for multiple type arguments. <paramref name="alwaysWrapsRequiredServiceType" /> need to be set 
            when generic wrapper type arguments should be ignored.</summary>
        </member>
        <member name="M:DryIoc.Setup.WrapperSetup.GetWrappedTypeOrNullIfWrapsRequired(System.Type)">
            <summary>Unwraps service type or returns the <paramref name="serviceType"/> as-is.</summary>
        </member>
        <member name="T:DryIoc.Setup.DecoratorSetup">
            <summary>Setup applied to decorators.</summary>
        </member>
        <member name="P:DryIoc.Setup.DecoratorSetup.FactoryType">
            <summary>Returns Decorator factory type.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.Order">
            <summary>If provided specifies relative decorator position in decorators chain.
            Greater number means further from decoratee - specify negative number to stay closer.
            Decorators without order (Order is 0) or with equal order are applied in registration order
            - first registered are closer decoratee.</summary>
        </member>
        <member name="F:DryIoc.Setup.DecoratorSetup.UseDecorateeReuse">
            <summary>Instructs to use decorated service reuse. Decorated service may be decorator itself.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor">
            <summary>Default setup.</summary>
        </member>
        <member name="M:DryIoc.Setup.DecoratorSetup.#ctor(System.Func{DryIoc.Request,System.Boolean},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>Creates decorator setup with optional condition. <paramref name="condition" /> applied to 
            decorated service to find that service is the decorator target. <paramref name="order" /> specifies 
            relative decorator position in decorators chain. Greater number means further from decoratee -
            specify negative number to stay closer. Decorators without order (Order is 0) or with equal order
            are applied in registration order - first registered are closer decoratee.</summary>
        </member>
        <member name="T:DryIoc.IConcreteFactoryGenerator">
            <summary>Facility for creating concrete factories from some template/prototype. Example:
            creating closed-generic type reflection factory from registered open-generic prototype factory.</summary>
        </member>
        <member name="P:DryIoc.IConcreteFactoryGenerator.GeneratedFactories">
            <summary>Generated factories so far, identified by the service type and key pair.</summary>
        </member>
        <member name="M:DryIoc.IConcreteFactoryGenerator.GetGeneratedFactory(DryIoc.Request,System.Boolean)">
            <summary>Returns factory per request. May track already generated factories and return one without regenerating.</summary>
        </member>
        <member name="T:DryIoc.FactoryCaching">
            Instructs how to deal with factory result expression: 
        </member>
        <member name="F:DryIoc.FactoryCaching.Default">
            Is up to DryIoc to decide,
        </member>
        <member name="F:DryIoc.FactoryCaching.PleaseDontSetDoNotCache">
            Prevents DryIoc to set `DoNotCache`.
        </member>
        <member name="F:DryIoc.FactoryCaching.DoNotCache">
            If set, the expression won't be cached 
        </member>
        <member name="T:DryIoc.Factory">
            <summary>Base class for different ways to instantiate service:
            <list type="bullet">
            <item>Through reflection - <see cref="T:DryIoc.ReflectionFactory"/></item>
            <item>Using custom delegate - <see cref="T:DryIoc.DelegateFactory"/></item>
            <item>Using custom expression - <see cref="T:DryIoc.ExpressionFactory"/></item>
            <item>A placeholder for future actual implementation - <see cref="T:DryIoc.FactoryPlaceholder"/></item>
            </list>
            For all of the types Factory should provide result as <see cref="T:FastExpressionCompiler.LightExpression.Expression"/> and <see cref="T:DryIoc.FactoryDelegate"/>.
            Factories are supposed to be immutable and stateless.
            Each created factory has an unique ID set in <see cref="P:DryIoc.Factory.FactoryID"/>.</summary>
        </member>
        <member name="M:DryIoc.Factory.GetNextID">
            <summary>Get next factory ID in a atomic way.</summary><returns>The ID.</returns>
        </member>
        <member name="P:DryIoc.Factory.FactoryID">
            <summary>Unique factory id generated from static seed.</summary>
        </member>
        <member name="P:DryIoc.Factory.Reuse">
            <summary>Reuse policy for created services.</summary>
        </member>
        <member name="P:DryIoc.Factory.Setup">
            <summary>Setup may contain different/non-default factory settings.</summary>
        </member>
        <member name="M:DryIoc.Factory.CheckCondition(DryIoc.Request)">
            <summary>Checks that condition is met for request or there is no condition setup.</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryType">
            <summary>Shortcut for <see cref="P:DryIoc.Setup.FactoryType"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.ImplementationType">
            <summary>Non-abstract closed implementation type. May be null if not known beforehand, e.g. in <see cref="T:DryIoc.DelegateFactory"/>.</summary>
        </member>
        <member name="P:DryIoc.Factory.CanAccessImplementationType">
            <summary>Allow inheritors to define lazy implementation type</summary>
        </member>
        <member name="P:DryIoc.Factory.FactoryGenerator">
            <summary>Indicates that Factory is factory provider and
            consumer should call <see cref="M:DryIoc.IConcreteFactoryGenerator.GetGeneratedFactory(DryIoc.Request,System.Boolean)"/> to get concrete factory.</summary>
        </member>
        <member name="P:DryIoc.Factory.RegistrationOrder">
            <summary>Registration order.</summary>
        </member>
        <member name="P:DryIoc.Factory.Made">
            <summary>Settings <b>(if any)</b> to select Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="P:DryIoc.Factory.HasRuntimeState">
            <summary>The factory inserts the runtime-state into result expression, e.g. delegate or pre-created instance.</summary>
        </member>
        <member name="P:DryIoc.Factory.Caching">
            Indicates how to deal with the result expression
        </member>
        <member name="M:DryIoc.Factory.DoNotCache">
            Instructs to skip caching the factory unless it really wants to do so via `PleaseDontSetDoNotCache`
        </member>
        <member name="M:DryIoc.Factory.#ctor(DryIoc.IReuse,DryIoc.Setup)">
            <summary>Initializes reuse and setup. Sets the <see cref="P:DryIoc.Factory.FactoryID"/></summary>
            <param name="reuse">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>The main factory method to create service expression, e.g. "new Client(new Service())".
            If <paramref name="request"/> has <see cref="F:DryIoc.Request.InputArgExprs"/> specified, they could be used in expression.</summary>
            <param name="request">Service request.</param>
            <returns>Created expression.</returns>
        </member>
        <member name="M:DryIoc.Factory.GetExpressionOrDefault(DryIoc.Request)">
            <summary>Returns service expression: either by creating it with <see cref="M:DryIoc.Factory.CreateExpressionOrDefault(DryIoc.Request)"/> or taking expression from cache.
            Before returning method may transform the expression  by applying <see cref="P:DryIoc.Factory.Reuse"/>, or/and decorators if found any.</summary>
        </member>
        <member name="M:DryIoc.Factory.ApplyReuse(FastExpressionCompiler.LightExpression.Expression,DryIoc.Request)">
            <summary>Applies reuse to created expression, by wrapping passed expression into scoped access
            and producing the result expression.</summary>
        </member>
        <member name="M:DryIoc.Factory.UseInterpretation(DryIoc.Request)">
            Instructs to ignore GetDelegateOrDefault and try the interpreter 
        </member>
        <member name="M:DryIoc.Factory.GetDelegateOrDefault(DryIoc.Request)">
            Creates factory delegate from service expression and returns it.
        </member>
        <member name="M:DryIoc.Factory.ToString">
            <summary>Returns nice string representation of factory.</summary>
        </member>
        <member name="T:DryIoc.FactoryMethodSelector">
            <summary>Declares delegate to get single factory method or constructor for resolved request.</summary>
        </member>
        <member name="T:DryIoc.ParameterSelector">
            <summary>Specifies how to get parameter info for injected parameter and resolved request</summary>
        </member>
        <member name="T:DryIoc.PropertiesAndFieldsSelector">
            <summary>Specifies what properties or fields to inject and how.</summary>
        </member>
        <member name="T:DryIoc.Parameters">
            <summary>DSL for specifying <see cref="T:DryIoc.ParameterSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.Parameters.Of">
            <summary>Returns default service info wrapper for each parameter info.</summary>
        </member>
        <member name="F:DryIoc.Parameters.IfUnresolvedReturnDefault">
            <summary>Returns service info which considers each parameter as optional.</summary>
        </member>
        <member name="M:DryIoc.Parameters.OverrideWith(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Combines source selector with other. Other is used as fallback when source returns null.</summary>
        </member>
        <member name="M:DryIoc.Parameters.And(DryIoc.ParameterSelector,DryIoc.ParameterSelector)">
            <summary>Obsolete: please use <see cref="M:DryIoc.Parameters.OverrideWith(DryIoc.ParameterSelector,DryIoc.ParameterSelector)"/></summary>
        </member>
        <member name="M:DryIoc.Parameters.Details(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Overrides source parameter rules with specific parameter details. 
            If it is not your parameter just return null.</summary>
            <param name="source">Original parameters rules</param>
            <param name="getDetailsOrNull">Should return specific details or null.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by <paramref name="name"/>.</summary>
            <param name="source">Original parameters rules.</param> <param name="name">Name to identify parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Specify parameter by name and set custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Name(DryIoc.ParameterSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by name and set custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type(DryIoc.ParameterSelector,System.Type,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <paramref name="parameterType"/>.</summary>
            <param name="source">Source selector.</param> <param name="parameterType">The type of the parameter.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <typeparamref name="T"/>.</summary>
            <typeparam name="T">Type of parameter.</typeparam> <param name="source">Source selector.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,System.Reflection.ParameterInfo,DryIoc.ServiceDetails})">
            <summary>Specify parameter by type and set its details.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type``1(DryIoc.ParameterSelector,System.Func{DryIoc.Request,``0})">
            <summary>Specify parameter by type and set custom value to it.</summary>
        </member>
        <member name="M:DryIoc.Parameters.Type(DryIoc.ParameterSelector,System.Type,System.Func{DryIoc.Request,System.Object})">
            <summary>Specify parameter by type and set custom value to it.</summary>
            <param name="source">Original parameters rules.</param>
            <param name="parameterType">The type of the parameter.</param>
            <param name="getCustomValue">Custom value provider.</param>
            <returns>New parameters rules.</returns>
        </member>
        <member name="T:DryIoc.PropertiesAndFields">
            <summary>DSL for specifying <see cref="T:DryIoc.PropertiesAndFieldsSelector"/> injection rules.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Of">
            <summary>Say to not resolve any properties or fields.</summary>
        </member>
        <member name="F:DryIoc.PropertiesAndFields.Auto">
            <summary>Public assignable instance members of any type except object, string, primitives types, and arrays of those.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Properties(System.Boolean,System.Boolean,DryIoc.IfUnresolved)">
            <summary>Public, declared, assignable, non-primitive properties.</summary>
        </member>
        <member name="T:DryIoc.PropertiesAndFields.GetServiceInfo">
            <summary>Should return service info for input member (property or field).</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.All(System.Boolean,System.Boolean,System.Boolean,System.Boolean,DryIoc.IfUnresolved,DryIoc.PropertiesAndFields.GetServiceInfo)">
            <summary>Generates selector property and field selector with settings specified by parameters.
            If all parameters are omitted the return all public not primitive members.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Combines source properties and fields with other. Other will override the source condition.</summary>
            <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
            <returns>Combined result selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.And(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)">
            <summary>Obsolete: please use <see cref="M:DryIoc.PropertiesAndFields.OverrideWith(DryIoc.PropertiesAndFieldsSelector,DryIoc.PropertiesAndFieldsSelector)"/></summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Details(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,DryIoc.ServiceDetails})">
            <summary>Specifies service details (key, if-unresolved policy, required type) for property/field with the name.</summary>
            <param name="source">Original member selector.</param> <param name="name">Member name.</param> <param name="getDetails">Details.</param>
            <returns>New selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Type,System.Object,DryIoc.IfUnresolved,System.Object,System.String,System.Object)">
            <summary>Adds to <paramref name="source"/> selector service info for property/field identified by <paramref name="name"/>.</summary>
            <param name="source">Source selector.</param> <param name="name">Name to identify member.</param>
            <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
            <param name="ifUnresolved">(optional) By default returns default value if unresolved.</param>
            <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
            <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
            <returns>Combined selector.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.Name(DryIoc.PropertiesAndFieldsSelector,System.String,System.Func{DryIoc.Request,System.Object})">
            <summary>Specifies custom value for property/field with specific name.</summary>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.PropertyInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if property matches flags provided.</summary>
            <param name="property">Property to match</param>
            <param name="withNonPublic">Says to include non public properties.</param>
            <param name="withPrimitive">Says to include properties of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="M:DryIoc.PropertiesAndFields.IsInjectable(System.Reflection.FieldInfo,System.Boolean,System.Boolean)">
            <summary>Returns true if field matches flags provided.</summary>
            <param name="field">Field to match.</param>
            <param name="withNonPublic">Says to include non public fields.</param>
            <param name="withPrimitive">Says to include fields of primitive type.</param>
            <returns>True if property is matched and false otherwise.</returns>
        </member>
        <member name="T:DryIoc.ReflectionFactory">
            <summary>Reflects on <see cref="P:DryIoc.ReflectionFactory.ImplementationType"/> constructor parameters and members,
            creates expression for each reflected dependency, and composes result service expression.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.ImplementationType">
            <summary>Non-abstract service implementation type. May be open generic.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.CanAccessImplementationType">
            <summary>False for lazy implementation type, to prevent its early materialization.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.FactoryGenerator">
            <summary>Provides closed-generic factory for registered open-generic variant.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.Made">
            <summary>Injection rules set for Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.GeneratorFactoryID">
            <summary>FactoryID of generator (open-generic) factory.</summary>
        </member>
        <member name="P:DryIoc.ReflectionFactory.RegistrationOrder">
            <summary>Will contain factory ID of generator's factory for generated factory.</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Type,DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
            <param name="implementationType">(optional) Optional if Made.FactoryMethod is present Non-abstract close or open generic type.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.#ctor(System.Func{System.Type},DryIoc.IReuse,DryIoc.Made,DryIoc.Setup)">
            <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
            <param name="implementationTypeProvider">Provider of non-abstract closed or open-generic type.</param>
            <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        </member>
        <member name="M:DryIoc.ReflectionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression.</summary>
        </member>
        <member name="M:DryIoc.ReflectionFactory.TryResolveParameterExpressions(System.Reflection.ParameterInfo[],System.Func{System.Reflection.ParameterInfo,DryIoc.ParameterServiceInfo},DryIoc.Request,System.Int32@)">
            Tries to create expressions for supplied parameters to use in factory method or constructor
        </member>
        <member name="T:DryIoc.ExpressionFactory">
            <summary>Creates service expression using client provided expression factory delegate.</summary>
        </member>
        <member name="M:DryIoc.ExpressionFactory.#ctor(System.Func{DryIoc.Request,FastExpressionCompiler.LightExpression.Expression},DryIoc.IReuse,DryIoc.Setup)">
            <summary>Wraps provided delegate into factory.</summary>
            <param name="getServiceExpression">Delegate that will be used internally to create service expression.</param>
            <param name="reuse">(optional) Reuse.</param> <param name="setup">(optional) Setup.</param>
        </member>
        <member name="M:DryIoc.ExpressionFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Creates service expression using wrapped delegate.</summary>
            <param name="request">Request to resolve.</param> <returns>Expression returned by stored delegate.</returns>
        </member>
        <member name="T:DryIoc.RegisteredInstanceFactory">
            Wraps the instance in registry
        </member>
        <member name="F:DryIoc.RegisteredInstanceFactory.Instance">
            The registered pre-created object instance
        </member>
        <member name="P:DryIoc.RegisteredInstanceFactory.ImplementationType">
            <summary>Non-abstract closed implementation type.</summary>
        </member>
        <member name="P:DryIoc.RegisteredInstanceFactory.HasRuntimeState">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.ValidateAndNormalizeRegistration(System.Type,System.Object,System.Boolean,DryIoc.Rules)">
            Simplified specially for register instance 
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.#ctor(System.Object,DryIoc.IReuse,DryIoc.Setup)">
            <summary>Creates factory.</summary>
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.CreateExpressionOrDefault(DryIoc.Request)">
            Wraps the instance in expression constant
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.GetExpressionOrDefault(DryIoc.Request)">
            Simplified path for the registered instance
        </member>
        <member name="M:DryIoc.RegisteredInstanceFactory.GetDelegateOrDefault(DryIoc.Request)">
            Used at resolution root too simplify getting the actual instance
        </member>
        <member name="T:DryIoc.DelegateFactory">
            <summary>This factory is the thin wrapper for user provided delegate
            and where possible it uses delegate directly: without converting it to expression.</summary>
        </member>
        <member name="P:DryIoc.DelegateFactory.ImplementationType">
            <summary>Non-abstract closed implementation type.</summary>
        </member>
        <member name="P:DryIoc.DelegateFactory.HasRuntimeState">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.DelegateFactory.#ctor(DryIoc.FactoryDelegate,DryIoc.IReuse,DryIoc.Setup,System.Type)">
            <summary>Creates factory.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.CreateExpressionOrDefault(DryIoc.Request)">
            <summary>Create expression by wrapping call to stored delegate with provided request.</summary>
        </member>
        <member name="M:DryIoc.DelegateFactory.GetDelegateOrDefault(DryIoc.Request)">
            <summary>If possible returns delegate directly, without creating expression trees, just wrapped in <see cref="T:DryIoc.FactoryDelegate"/>.
            If decorator found for request then factory fall-backs to expression creation.</summary>
            <param name="request">Request to resolve.</param>
            <returns>Factory delegate directly calling wrapped delegate, or invoking expression if decorated.</returns>
        </member>
        <member name="T:DryIoc.CreateScopedValue">
            <summary>Should return value stored in scope.</summary>
        </member>
        <member name="T:DryIoc.IScope">
            <summary>Lazy object storage that will create object with provided factory on first access,
            then will be returning the same object for subsequent access.</summary>
        </member>
        <member name="P:DryIoc.IScope.Parent">
            <summary>Parent scope in scope stack. Null for root scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.Name">
            <summary>Optional name object associated with scope.</summary>
        </member>
        <member name="P:DryIoc.IScope.IsDisposed">
            <summary>True if scope is disposed.</summary>
        </member>
        <member name="M:DryIoc.IScope.TryGet(System.Object@,System.Int32)">
            <summary>Looks up for stored item by id.</summary>
        </member>
        <member name="M:DryIoc.IScope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue,System.Int32)">
            Creates, stores, and returns created item
        </member>
        <member name="M:DryIoc.IScope.GetOrAddViaFactoryDelegate(System.Int32,DryIoc.FactoryDelegate,DryIoc.IResolverContext,System.Int32)">
            Create the value via `FactoryDelegate` if it is available
        </member>
        <member name="M:DryIoc.IScope.TryGetOrAddWithoutClosure(System.Int32,DryIoc.IResolverContext,FastExpressionCompiler.LightExpression.Expression,System.Boolean,System.Func{DryIoc.IResolverContext,FastExpressionCompiler.LightExpression.Expression,System.Boolean,System.Object},System.Int32)">
            Creates, stores, and returns created item
        </member>
        <member name="M:DryIoc.IScope.TrackDisposable(System.Object,System.Int32)">
            <summary>Tracked item will be disposed with the scope. 
            Smaller <paramref name="disposalOrder"/> will be disposed first.</summary>
        </member>
        <member name="M:DryIoc.IScope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
        </member>
        <member name="M:DryIoc.IScope.GetOrTryAdd(System.Int32,System.Object,System.Int32)">
            <summary>Gets and existing value at specified id, or adds a new value if no-one was added in between.</summary>
        </member>
        <member name="M:DryIoc.IScope.SetUsedInstance(System.Type,DryIoc.FactoryDelegate)">
            Sets (replaces) the factory for specified type.
        </member>
        <member name="M:DryIoc.IScope.TryGetUsedInstance(DryIoc.IResolverContext,System.Type,System.Object@)">
            Looks up for stored item by type.
        </member>
        <member name="M:DryIoc.IScope.Clone">
            Clones the scope.
        </member>
        <member name="T:DryIoc.Scope">
            <summary>Scope implementation to hold and dispose stored <see cref="T:System.IDisposable"/> items.
            <c>lock</c> is used internally to ensure that object factory called only once.</summary>
        </member>
        <member name="P:DryIoc.Scope.Parent">
            <summary>Parent scope in scope stack. Null for the root scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.Name">
            <summary>Optional name associated with scope.</summary>
        </member>
        <member name="P:DryIoc.Scope.IsDisposed">
            <summary>True if scope is disposed.</summary>
        </member>
        <member name="M:DryIoc.Scope.#ctor(DryIoc.IScope,System.Object)">
            <summary>Creates scope with optional parent and name.</summary>
        </member>
        <member name="M:DryIoc.Scope.GetOrAdd(System.Int32,DryIoc.CreateScopedValue,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.GetOrAddViaFactoryDelegate(System.Int32,DryIoc.FactoryDelegate,DryIoc.IResolverContext,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.TryGetOrAddWithoutClosure(System.Int32,DryIoc.IResolverContext,FastExpressionCompiler.LightExpression.Expression,System.Boolean,System.Func{DryIoc.IResolverContext,FastExpressionCompiler.LightExpression.Expression,System.Boolean,System.Object},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.SetOrAdd(System.Int32,System.Object)">
            <summary>Sets (replaces) value at specified id, or adds value if no existing id found.</summary>
            <param name="id">To set value at. Should be >= 0.</param> <param name="item">Value to set.</param>
        </member>
        <member name="M:DryIoc.Scope.GetOrTryAdd(System.Int32,System.Object,System.Int32)">
            Try to set the value if it is not already set
        </member>
        <member name="M:DryIoc.Scope.Clone">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.TryGet(System.Object@,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.Scope.TrackDisposable(System.Object,System.Int32)">
            <summary>Can be used to manually add service for disposal</summary>
        </member>
        <member name="M:DryIoc.Scope.SetUsedInstance(System.Type,DryIoc.FactoryDelegate)">
            Add instance to the small registry via factory
        </member>
        <member name="M:DryIoc.Scope.TryGetUsedInstance(DryIoc.IResolverContext,System.Type,System.Object@)">
            Try retrieve instance from the small registry.
        </member>
        <member name="M:DryIoc.Scope.GetEnumerator">
            <summary>Enumerates all the parent scopes upwards starting from this one.</summary>
        </member>
        <member name="M:DryIoc.Scope.Dispose">
            <summary>Disposes all stored <see cref="T:System.IDisposable"/> objects and empties item storage.
            The disposal happens in REVERSE resolution / injection order, consumer first, dependency next.
            It will allow consumer to do something with its dependency before it is disposed.</summary>
            <remarks>All disposal exceptions are swallowed except the ContainerException,
            which may indicate container misconfiguration.</remarks>
        </member>
        <member name="M:DryIoc.Scope.ToString">
            <summary>Prints scope info (name and parent) to string for debug purposes.</summary>
        </member>
        <member name="T:DryIoc.SetCurrentScopeHandler">
            <summary>Delegate to get new scope from old/existing current scope.</summary>
            <param name="oldScope">Old/existing scope to change.</param>
            <returns>New scope or old if do not want to change current scope.</returns>
        </member>
        <member name="T:DryIoc.IScopeContext">
            <summary>Provides ambient current scope and optionally scope storage for container,
            examples are HttpContext storage, Execution context, Thread local.</summary>
        </member>
        <member name="M:DryIoc.IScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.IScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and
            should return new current scope.</summary>
            <param name="setCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. So it is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="T:DryIoc.ThreadScopeContext">
            <summary>Tracks one current scope per thread, so the current scope in different tread would be different or null,
            if not yet tracked. Context actually stores scope references internally, so it should be disposed to free them.</summary>
        </member>
        <member name="F:DryIoc.ThreadScopeContext.ScopeContextName">
            <summary>Provides static name for context. It is OK because its constant.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope in calling Thread or null, if no scope tracked.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Change current scope for the calling Thread.</summary>
        </member>
        <member name="M:DryIoc.ThreadScopeContext.Dispose">
            <summary>Disposes the scopes and empties internal scope storage.</summary>
        </member>
        <member name="T:DryIoc.IReuse">
            <summary>Simplified scope agnostic reuse abstraction. More easy to implement,
             and more powerful as can be based on other storage beside reuse.</summary>
        </member>
        <member name="P:DryIoc.IReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.IReuse.Name">
            <summary>Optional name. Use to find matching scope by the name.
            It also may be interpreted as object[] Names for matching with multiple scopes </summary>
        </member>
        <member name="M:DryIoc.IReuse.CanApply(DryIoc.Request)">
            <summary>Returns true if reuse can be applied: may check if scope or other reused item storage is present.</summary>
        </member>
        <member name="M:DryIoc.IReuse.Apply(DryIoc.Request,FastExpressionCompiler.LightExpression.Expression)">
            <summary>Returns composed expression.</summary>
        </member>
        <member name="T:DryIoc.SingletonReuse">
            <summary>Returns container bound scope for storing singleton objects.</summary>
        </member>
        <member name="F:DryIoc.SingletonReuse.DefaultLifespan">
            <summary>Big lifespan.</summary>
        </member>
        <member name="P:DryIoc.SingletonReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.SingletonReuse.Name">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.SingletonReuse.CanApply(DryIoc.Request)">
            <summary>Returns true because singleton is always available.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.Apply(DryIoc.Request,FastExpressionCompiler.LightExpression.Expression)">
            <summary>Returns expression call to GetOrAddItem.</summary>
        </member>
        <member name="M:DryIoc.SingletonReuse.ToExpression(System.Func{System.Object,FastExpressionCompiler.LightExpression.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.SingletonReuse.ToString">
            <summary>Pretty prints reuse name and lifespan</summary>
        </member>
        <member name="T:DryIoc.CurrentScopeReuse">
            <summary>Specifies that instances are created, stored and disposed together with some scope.</summary>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.DefaultLifespan">
            <summary>Less than Singleton's</summary>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Lifespan">
            <summary>Relative to other reuses lifespan value.</summary>
        </member>
        <member name="P:DryIoc.CurrentScopeReuse.Name">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.CanApply(DryIoc.Request)">
            <summary>Returns true if scope is open and the name is matching with reuse <see cref="P:DryIoc.CurrentScopeReuse.Name"/>.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.Apply(DryIoc.Request,FastExpressionCompiler.LightExpression.Expression)">
            <summary>Creates scoped item creation and access expression.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToExpression(System.Func{System.Object,FastExpressionCompiler.LightExpression.Expression})">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.ToString">
            <summary>Pretty prints reuse to string.</summary> <returns>Reuse string.</returns>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.#ctor(System.Object,System.Boolean)">
            <summary>Creates reuse optionally specifying its name.</summary>
        </member>
        <member name="F:DryIoc.CurrentScopeReuse.ScopedOrSingleton">
            <summary>Flag indicating that it is a scope or singleton.</summary>
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedOrSingleton(DryIoc.IResolverContext,System.Int32,DryIoc.CreateScopedValue,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedOrSingletonViaFactoryDelegate(DryIoc.IResolverContext,System.Int32,DryIoc.FactoryDelegate,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackScopedOrSingleton(DryIoc.IResolverContext,System.Object)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScoped(DryIoc.IResolverContext,System.Boolean,System.Int32,DryIoc.CreateScopedValue,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetScopedViaFactoryDelegate(DryIoc.IResolverContext,System.Boolean,System.Int32,DryIoc.FactoryDelegate,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.GetNameScoped(DryIoc.IResolverContext,System.Object,System.Boolean,System.Int32,DryIoc.CreateScopedValue,System.Int32)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackScoped(DryIoc.IResolverContext,System.Boolean,System.Object)">
            Subject
        </member>
        <member name="M:DryIoc.CurrentScopeReuse.TrackNameScoped(DryIoc.IResolverContext,System.Object,System.Boolean,System.Object)">
            Subject
        </member>
        <member name="T:DryIoc.IScopeName">
            <summary>Abstracts way to match reuse and scope names</summary>
        </member>
        <member name="M:DryIoc.IScopeName.Match(System.Object)">
            <summary>Does the job.</summary>
        </member>
        <member name="T:DryIoc.CompositeScopeName">
            <summary>Represents multiple names</summary>
        </member>
        <member name="M:DryIoc.CompositeScopeName.Of(System.Object[])">
            <summary>Wraps multiple names</summary>
        </member>
        <member name="M:DryIoc.CompositeScopeName.Match(System.Object)">
            <summary>Matches all the name in a loop until first match is found, otherwise returns false.</summary>
        </member>
        <member name="T:DryIoc.ResolutionScopeName">
            <summary>Holds the name for the resolution scope.</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Of(System.Type,System.Object)">
            <summary>Creates scope with specified service type and key</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Of``1(System.Object)">
            <summary>Creates scope with specified service type and key.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeName.ServiceType">
            <summary>Type of service opening the scope.</summary>
        </member>
        <member name="F:DryIoc.ResolutionScopeName.ServiceKey">
            <summary>Optional service key of service opening the scope.</summary>
        </member>
        <member name="M:DryIoc.ResolutionScopeName.Match(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DryIoc.ResolutionScopeName.ToString">
            <summary>String representation for easy debugging and understood error messages.</summary>
        </member>
        <member name="T:DryIoc.Reuse">
            <summary>Specifies pre-defined reuse behaviors supported by container:
            used when registering services into container with <see cref="T:DryIoc.Registrator"/> methods.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Transient">
            <summary>Synonym for absence of reuse.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Singleton">
            <summary>Specifies to store single service instance per <see cref="T:DryIoc.Container"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.Scoped">
            <summary>Same as InCurrentScope. From now on will be the default name.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Object)">
            <summary>Same as InCurrentNamedScope. From now on will be the default name.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Object[])">
            <summary>Scoped to multiple names.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo(System.Type,System.Object)">
            <summary>Same as InResolutionScopeOf. From now on will be the default name.</summary>
        </member>
        <member name="M:DryIoc.Reuse.ScopedTo``1(System.Object)">
            <summary>Same as InResolutionScopeOf. From now on will be the default name.</summary>
        </member>
        <member name="F:DryIoc.Reuse.ScopedOrSingleton">
            <summary>The same as <see cref="F:DryIoc.Reuse.InCurrentScope"/> but if no open scope available will fallback to <see cref="F:DryIoc.Reuse.Singleton"/></summary>
            <remarks>The <see cref="F:DryIoc.Error.DependencyHasShorterReuseLifespan"/> is applied the same way as for <see cref="F:DryIoc.Reuse.InCurrentScope"/> reuse.</remarks>
        </member>
        <member name="F:DryIoc.Reuse.InResolutionScope">
            <summary>Obsolete: same as <see cref="F:DryIoc.Reuse.Scoped"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InCurrentScope">
            <summary>Obsolete: same as <see cref="F:DryIoc.Reuse.Scoped"/>.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InCurrentNamedScope(System.Object)">
            <summary>Returns current scope reuse with specific name to match with scope.
            If name is not specified then function returns <see cref="F:DryIoc.Reuse.InCurrentScope"/>.</summary>
            <param name="name">(optional) Name to match with scope.</param>
            <returns>Created current scope reuse.</returns>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf(System.Type,System.Object)">
            <summary>Obsolete: please use ScopedTo instead.</summary>
        </member>
        <member name="M:DryIoc.Reuse.InResolutionScopeOf``1(System.Object)">
            <summary>Obsolete: please use ScopedTo instead.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InThread">
            <summary>Same as Scoped but requires <see cref="T:DryIoc.ThreadScopeContext"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.WebRequestScopeName">
            <summary>Special name that by convention recognized by <see cref="F:DryIoc.Reuse.InWebRequest"/>.</summary>
        </member>
        <member name="F:DryIoc.Reuse.InWebRequest">
            <summary>Obsolete: please prefer using <see cref="F:DryIoc.Reuse.Scoped"/> instead.
            The named scope has performance drawback comparing to just a scope.
            If you need to distinguish nested scope, give names to them instead of naming the top web request scope.</summary>
        </member>
        <member name="T:DryIoc.IfUnresolved">
            <summary>Policy to handle unresolved service.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.Throw">
            <summary>If service is unresolved for whatever means, it will throw the respective exception.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefault">
            <summary>If service is unresolved for whatever means, it will return default(serviceType) value.</summary>
        </member>
        <member name="F:DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered">
            <summary>If service is not registered, then it will return default, for other errors it will throw.</summary>
        </member>
        <member name="T:DryIoc.IResolver">
            <summary>Declares minimal API for service resolution. 
            Resolve default and keyed is separated because of optimization for faster resolution of the former.</summary>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,DryIoc.IfUnresolved)">
            <summary>Resolves default (non-keyed) service from container and returns created service object.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="ifUnresolved">Says what to do if service is unresolved.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolved"/> provided.</returns>
        </member>
        <member name="M:DryIoc.IResolver.Resolve(System.Type,System.Object,DryIoc.IfUnresolved,System.Type,DryIoc.Request,System.Object[])">
            <summary>Resolves service instance from container.</summary>
            <param name="serviceType">Service type to search and to return.</param>
            <param name="serviceKey">(optional) service key used for registering service.</param>
            <param name="ifUnresolved">(optional) Says what to do if service is unresolved.</param>
            <param name="requiredServiceType">(optional) Registered or wrapped service type to use instead of <paramref name="serviceType"/>,
                or wrapped type for generic wrappers.  The type should be assignable to return <paramref name="serviceType"/>.</param>
            <param name="preResolveParent">(optional) Dependency chain info.</param>
            <param name="args">(optional) To specify the dependency objects to use instead of resolving them from container.</param>
            <returns>Created service object or default based on <paramref name="ifUnresolved"/> parameter.</returns>
        </member>
        <member name="M:DryIoc.IResolver.ResolveMany(System.Type,System.Object,System.Type,DryIoc.Request,System.Object[])">
            <summary>Resolves all services registered for specified <paramref name="serviceType"/>, or if not found returns
            empty enumerable. If <paramref name="serviceType"/> specified then returns only (single) service registered with this type.</summary>
            <param name="serviceType">Return type of an service item.</param>
            <param name="serviceKey">(optional) Resolve only single service registered with the key.</param>
            <param name="requiredServiceType">(optional) Actual registered service to search for.</param>
            <param name="preResolveParent">Dependency resolution path info.</param>
            <param name="args">(optional) To specify the dependency objects to use instead of resolving them from container.</param>
            <returns>Enumerable of found services or empty. Does Not throw if no service found.</returns>
        </member>
        <member name="T:DryIoc.IfAlreadyRegistered">
            <summary>Specifies options to handle situation when registered service is already present in the registry.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNotKeyed">
            <summary>Appends new default registration or throws registration with the same key.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Throw">
            <summary>Throws if default or registration with the same key is already exist.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Keep">
            <summary>Keeps old default or keyed registration ignoring new registration: ensures Register-Once semantics.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.Replace">
            <summary>Replaces old registration with new one.</summary>
        </member>
        <member name="F:DryIoc.IfAlreadyRegistered.AppendNewImplementation">
            <summary>Adds the new implementation or null (Made.Of),
            otherwise keeps the previous registration of the same implementation type.</summary>
        </member>
        <member name="T:DryIoc.ServiceRegistrationInfo">
            <summary>Existing registration info.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.Factory">
            <summary>Registered factory.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.ServiceType">
            <summary>Required service type.</summary>
        </member>
        <member name="F:DryIoc.ServiceRegistrationInfo.OptionalServiceKey">
            <summary>May be <c>null</c> for single default service, or <see cref="T:DryIoc.DefaultKey"/> for multiple default services.</summary>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.FactoryRegistrationOrder">
            <summary>Provides registration order across all factory registrations in container.</summary>
            <remarks>May be the same for factory registered with multiple services
            OR for closed-generic factories produced from the single open-generic registration.</remarks>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.ImplementationType">
            <summary>Implementation type if available.</summary>
        </member>
        <member name="P:DryIoc.ServiceRegistrationInfo.AsResolutionRoot">
            <summary>Shortcut to <see cref="P:DryIoc.Setup.AsResolutionRoot"/> property, useful to find all roots</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo">
            <summary>Shortcut to service info.</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo(System.Type)">
            <summary>Overrides the service type and pushes the original service type to required service type</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToServiceInfo``1">
            <summary>Overrides the service type and pushes the original service type to required service type</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.#ctor(DryIoc.Factory,System.Type,System.Object)">
            <summary>Creates info. Registration order is figured out automatically based on Factory.</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.CompareTo(DryIoc.ServiceRegistrationInfo)">
            <summary>Orders by registration</summary>
        </member>
        <member name="M:DryIoc.ServiceRegistrationInfo.ToString">
            <summary>Pretty-prints info to string.</summary>
        </member>
        <member name="T:DryIoc.IRegistrator">
            <summary>Defines operations that for changing registry, and checking if something exist in registry.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.Register(DryIoc.Factory,System.Type,System.Object,System.Nullable{DryIoc.IfAlreadyRegistered},System.Boolean)">
            <summary>Registers factory in registry with specified service type and key for lookup.
            Returns true if factory was added to registry, false otherwise. False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/>
            setting and already existing factory</summary>
            <param name="factory">To register.</param>
            <param name="serviceType">Service type as unique key in registry for lookup.</param>
            <param name="serviceKey">Service key as complementary lookup for the same service type.</param>
            <param name="ifAlreadyRegistered">Policy how to deal with already registered factory with same service type and key.</param>
            <param name="isStaticallyChecked">[performance] Confirms that service and implementation types are statically checked by compiler.</param>
            <returns>True if factory was added to registry, false otherwise.
            False may be in case of <see cref="F:DryIoc.IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
        </member>
        <member name="M:DryIoc.IRegistrator.IsRegistered(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Returns true if expected factory is registered with specified service key and type.
            Not provided or <c>null</c> <paramref name="serviceKey"/> means to check the <paramref name="serviceType"/> 
            alone with any service key.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.Unregister(System.Type,System.Object,DryIoc.FactoryType,System.Func{DryIoc.Factory,System.Boolean})">
            <summary>Removes factory with specified service type and key from registry and cache.
            BUT consuming services may still hold on the resolved service instance.
            The cache of consuming services may also hold on the unregistered service. Use `IContainer.ClearCache` to clear all cache.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetServiceRegistrations">
            <summary>Returns all registered service factories with their Type and optional Key.
            Decorator and Wrapper types are not included.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.GetRegisteredFactories(System.Type,System.Object,DryIoc.FactoryType)">
            <summary>Searches for registered factories by type, and key (if specified),
            and by factory type (by default uses <see cref="F:DryIoc.FactoryType.Service"/>).
            May return empty, 1 or multiple factories.</summary>
        </member>
        <member name="M:DryIoc.IRegistrator.UseInstance(System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            Puts instance into the current scope or singletons.
        </member>
        <member name="M:DryIoc.IRegistrator.Use(System.Type,DryIoc.FactoryDelegate)">
            Puts instance created via the passed factory on demand into the current or singleton scope
        </member>
        <member name="T:DryIoc.RegistrySharing">
            <summary>What to do with registrations when creating the new container from the existent one.</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.Share">
            <summary>Shares both registrations and resolution cache if any</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.CloneButKeepCache">
            <summary>Clones the registrations but preserves the resolution cache</summary>
        </member>
        <member name="F:DryIoc.RegistrySharing.CloneAndDropCache">
            <summary>Clones the registrations and drops the cache -- full reset!</summary>
        </member>
        <member name="T:DryIoc.IContainer">
            <summary>Combines registrator and resolver roles, plus rules and scope management.</summary>
        </member>
        <member name="P:DryIoc.IContainer.Rules">
            <summary>Rules for defining resolution/registration behavior throughout container.</summary>
        </member>
        <member name="P:DryIoc.IContainer.OwnCurrentScope">
            <summary>Represents scope bound to container itself, and not an ambient (context) thingy.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope)">
            <summary>Creates new container from the current one by specifying the listed parameters.
            If the null or default values are provided then the default or new values will be applied.
            Nothing will be inherited from the current container.
            If you want to inherit something you need to provide it as parameter.</summary>
        </member>
        <member name="M:DryIoc.IContainer.With(DryIoc.IResolverContext,DryIoc.Rules,DryIoc.IScopeContext,DryIoc.RegistrySharing,DryIoc.IScope,DryIoc.IScope)">
            <summary>Creates new container from the current one by specifying the listed parameters.
            If the null or default values are provided then the default or new values will be applied.
            Nothing will be inherited from the current container.
            If you want to inherit something you need to provide it as parameter.</summary>
        </member>
        <member name="M:DryIoc.IContainer.WithNoMoreRegistrationAllowed(System.Boolean)">
            <summary>Produces new container which prevents any further registrations.</summary>
            <param name="ignoreInsteadOfThrow">(optional)Controls what to do with registrations: ignore or throw exception.
            Throws exception by default.</param>
            <returns>New container preserving all current container state but disallowing registrations.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ResolveFactory(DryIoc.Request)">
            <summary>Searches for requested factory in registry, and then using <see cref="P:DryIoc.Rules.UnknownServiceResolvers"/>.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory, otherwise null if <see cref="P:DryIoc.Request.IfUnresolved"/> is set to <see cref="F:DryIoc.IfUnresolved.ReturnDefault"/>.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetServiceFactoryOrDefault(DryIoc.Request)">
            <summary>Searches for registered service factory and returns it, or null if not found.
            Will use <see cref="P:DryIoc.Rules.FactorySelector"/> if specified.</summary>
            <param name="request">Factory request.</param>
            <returns>Found factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetAllServiceFactories(System.Type,System.Boolean)">
            <summary>Finds all registered default and keyed service factories and returns them.
            It skips decorators and wrappers.</summary>
            <param name="serviceType">Service type to look for, may be open-generic type too.</param>
            <param name="bothClosedAndOpenGenerics">(optional) For generic serviceType instructs to look for
            both closed and open-generic registrations.</param>
            <returns>Enumerable of found pairs.</returns>
            <remarks>Returned Key item should not be null - it should be <see cref="F:DryIoc.DefaultKey.Value"/>.</remarks>
        </member>
        <member name="M:DryIoc.IContainer.GetWrapperFactoryOrDefault(System.Type)">
            <summary>Searches for registered wrapper factory and returns it, or null if not found.</summary>
            <param name="serviceType">Service type to look for.</param> <returns>Found wrapper factory or null.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorFactoriesOrDefault(System.Type)">
            <summary>Returns all decorators registered for the service type.</summary> <returns>Decorator factories.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetDecoratorExpressionOrDefault(DryIoc.Request)">
            <summary>Creates decorator expression: it could be either Func{TService,TService},
            or service expression for replacing decorators.</summary>
            <param name="request">Decorated service request.</param>
            <returns>Decorator expression.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetWrappedType(System.Type,System.Type)">
            <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
            and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
            Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
            <param name="serviceType">Type to unwrap. Method will return early if type is not generic.</param>
            <param name="requiredServiceType">Required service type or null if don't care.</param>
            <returns>Unwrapped service type in case it corresponds to registered generic wrapper, or input type in all other cases.</returns>
        </member>
        <member name="M:DryIoc.IContainer.GetConstantExpression(System.Object,System.Type,System.Boolean)">
            <summary>Converts known items into custom expression or wraps in a constant expression.</summary>
            <param name="item">Item to convert.</param>
            <param name="itemType">(optional) Type of item, otherwise item <see cref="M:System.Object.GetType"/>.</param>
            <param name="throwIfStateRequired">(optional) Throws for non-primitive and not-recognized items,
            identifying that result expression require run-time state. For compiled expression it means closure in lambda delegate.</param>
            <returns>Returns constant or state access expression for added items.</returns>
        </member>
        <member name="M:DryIoc.IContainer.ClearCache(System.Type,System.Nullable{DryIoc.FactoryType},System.Object)">
            <summary>Clears cache for specified service(s). But does not clear instances of already resolved/created singletons and scoped services!</summary>
            <param name="serviceType">Target service type.</param>
            <param name="factoryType">(optional) If not specified, clears cache for all <see cref="T:DryIoc.FactoryType"/>.</param>
            <param name="serviceKey">(optional) If omitted, the cache will be cleared for all registrations of <paramref name="serviceType"/>.</param>
            <returns>True if target service was found, false - otherwise.</returns>
        </member>
        <member name="M:DryIoc.IContainer.UseInstance(System.Type,System.Object,DryIoc.IfAlreadyRegistered,System.Boolean,System.Boolean,System.Object)">
            <summary>Puts and instance into the current scope or singletons.</summary>
        </member>
        <member name="M:DryIoc.IContainer.Use(System.Type,DryIoc.FactoryDelegate)">
            Puts instance created via the passed factory on demand into the current or singleton scope
        </member>
        <member name="T:DryIoc.LazyEnumerable`1">
            <summary>Resolves all registered services of <typeparamref name="TService"/> type on demand,
            when enumerator <see cref="M:System.Collections.IEnumerator.MoveNext"/> called. If service type is not found, empty returned.</summary>
            <typeparam name="TService">Service type to resolve.</typeparam>
        </member>
        <member name="F:DryIoc.LazyEnumerable`1.Items">
            <summary>Exposes internal items enumerable.</summary>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Wraps lazy resolved items.</summary> <param name="items">Lazy resolved items.</param>
        </member>
        <member name="M:DryIoc.LazyEnumerable`1.GetEnumerator">
            <summary>Return items enumerator.</summary> 
        </member>
        <member name="T:DryIoc.Meta`2">
            <summary>Wrapper type to box service with associated arbitrary metadata object.</summary>
            <typeparam name="T">Service type.</typeparam>
            <typeparam name="TMetadata">Arbitrary metadata object type.</typeparam>
        </member>
        <member name="F:DryIoc.Meta`2.Value">
            <summary>Value or object with associated metadata.</summary>
        </member>
        <member name="F:DryIoc.Meta`2.Metadata">
            <summary>Associated metadata object. Could be anything.</summary>
        </member>
        <member name="M:DryIoc.Meta`2.#ctor(`0,`1)">
            <summary>Boxes value and its associated metadata together.</summary>
        </member>
        <member name="T:DryIoc.ContainerException">
            Exception that container throws in case of error. Dedicated exception type simplifies
            filtering or catching container relevant exceptions from client code.
        </member>
        <member name="F:DryIoc.ContainerException.Error">
            <summary>Error code of exception, possible values are listed in <see cref="F:DryIoc.ContainerException.Error"/> class.</summary>
        </member>
        <member name="P:DryIoc.ContainerException.ErrorName">
            <summary>Simplifies the access to the error name.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.Of(DryIoc.ErrorCheck,System.Int32,System.Object,System.Object,System.Object,System.Object,System.Exception)">
            <summary>Creates exception by wrapping <paramref name="errorCode"/> and its message,
            optionally with <paramref name="innerException"/> exception.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.GetMessage(DryIoc.ErrorCheck,System.Int32)">
            <summary>Gets error message based on provided args.</summary> <param name="errorCheck"></param> <param name="errorCode"></param>
        </member>
        <member name="M:DryIoc.ContainerException.Print(System.Object)">
            <summary>Prints argument for formatted message.</summary> <param name="arg">To print.</param> <returns>Printed string.</returns>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>Creates exception with message describing cause and context of error,
            and leading/system exception causing it.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Int32,System.String)">
            <summary>Creates exception with message describing cause and context of error.</summary>
        </member>
        <member name="M:DryIoc.ContainerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:DryIoc.Error">
            <summary>Defines error codes and error messages for all DryIoc exceptions (DryIoc extensions may define their own.)</summary>
        </member>
        <member name="F:DryIoc.Error.Messages">
            <summary>List of error messages indexed with code.</summary>
        </member>
        <member name="M:DryIoc.Error.NameOf(System.Int32)">
            <summary>Returns the name of error with the provided error code.</summary>
        </member>
        <member name="T:DryIoc.ErrorCheck">
            <summary>Checked error condition, possible error sources.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.Unspecified">
            <summary>Unspecified, just throw.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.InvalidCondition">
            <summary>Predicate evaluated to false.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNull">
            <summary>Checked object is null.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.IsNotOfType">
            <summary>Checked object is of unexpected type.</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.TypeIsNotOfType">
            <summary>Checked type is not assignable to expected type</summary>
        </member>
        <member name="F:DryIoc.ErrorCheck.OperationThrows">
            <summary>Invoked operation throws, it is source of inner exception.</summary>
        </member>
        <member name="T:DryIoc.Throw">
            <summary>Enables more clean error message formatting and a bit of code contracts.</summary>
        </member>
        <member name="M:DryIoc.Throw.GetDefaultMessage(DryIoc.ErrorCheck)">
            <summary>Returns the default message specified for <see cref="T:DryIoc.ErrorCheck"/> code.</summary>
        </member>
        <member name="T:DryIoc.Throw.GetMatchedExceptionHandler">
            <summary>Declares mapping between <see cref="T:DryIoc.ErrorCheck"/> type and <paramref name="error"/> code to specific <see cref="T:System.Exception"/>.</summary>
        </member>
        <member name="F:DryIoc.Throw.GetMatchedException">
            <summary>Returns matched exception for error check and error code.</summary>
        </member>
        <member name="M:DryIoc.Throw.If(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception with provided error code if throw condition is true.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIf``1(``0,System.Boolean,System.Int32,System.Object,System.Object,System.Object)">
            <summary>Throws matched exception with provided error code if throw condition is true.
            Otherwise returns source <paramref name="arg0"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNull``1(``0,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg"/> is null, otherwise returns <paramref name="arg"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotInstanceOf``1(``0,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws exception if <paramref name="arg0"/> is not assignable to type specified by <paramref name="arg1"/>,
            otherwise just returns <paramref name="arg0"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.ThrowIfNotImplementedBy(System.Type,System.Type,System.Int32,System.Object,System.Object)">
            <summary>Throws if <paramref name="arg0"/> is not assignable from <paramref name="arg1"/>.</summary>
        </member>
        <member name="M:DryIoc.Throw.IfThrows``2(System.Func{``1},System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Invokes <paramref name="operation"/> and in case of <typeparamref name="TEx"/> re-throws it as inner-exception.</summary>
        </member>
        <member name="M:DryIoc.Throw.It(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Int32,System.Object,System.Object,System.Object,System.Object)">
            <summary>Throws <paramref name="error"/> instead of returning value of <typeparamref name="T"/>.
            Supposed to be used in expression that require some return value.</summary>
        </member>
        <member name="M:DryIoc.Throw.For``1(System.Boolean,System.Int32,System.Object,System.Object,System.Object,System.Object)">
            Throws if contidion is true, otherwise returns the `default(T)` value
        </member>
        <member name="T:DryIoc.ThrowInGeneratedCode">
            <summary>Called from generated code.</summary>
        </member>
        <member name="M:DryIoc.ThrowInGeneratedCode.WeakRefReuseWrapperGCed(System.Object)">
            <summary>Throws if object is null.</summary>
        </member>
        <member name="T:DryIoc.RefMap">
            Hiding the lambda in the method call, so it is not needed it won't be allocated
        </member>
        <member name="T:DryIoc.ReflectionTools">
            <summary>Contains helper methods to work with Type: for instance to find Type implemented base types and interfaces, etc.</summary>
        </member>
        <member name="T:DryIoc.ReflectionTools.AsImplementedType">
            <summary>Flags for <see cref="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)"/> method.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.None">
            <summary>Include nor object not source type.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.SourceType">
            <summary>Include source type to list of implemented types.</summary>
        </member>
        <member name="F:DryIoc.ReflectionTools.AsImplementedType.ObjectType">
            <summary>Include <see cref="T:System.Object"/> type to list of implemented types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedTypes(System.Type,DryIoc.ReflectionTools.AsImplementedType)">
            <summary>Returns all interfaces and all base types (in that order) implemented by <paramref name="sourceType"/>.
            Specify <paramref name="asImplementedType"/> to include <paramref name="sourceType"/> itself as first item and
            <see cref="T:System.Object"/> type as the last item.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetImplementedInterfaces(System.Type)">
            <summary>Gets a collection of the interfaces implemented by the current type and its base types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAllMembers(System.Type,System.Boolean)">
            <summary>Gets all declared and if specified, the base members too.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.ContainsAllGenericTypeParameters(System.Type,System.Type[])">
            <summary>Returns true if the <paramref name="openGenericType"/> contains all generic parameters
            from <paramref name="genericParameters"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsCompilerGenerated(System.Type)">
            <summary>Returns true if class is compiler generated. Checking for CompilerGeneratedAttribute
            is not enough, because this attribute is not applied for classes generated from "async/await".</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGeneric(System.Type)">
            <summary>Returns true if type is generic.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsGenericDefinition(System.Type)">
            <summary>Returns true if type is generic type definition (open type).</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosedGeneric(System.Type)">
            <summary>Returns true if type is closed generic: does not have open generic parameters, only closed/concrete ones.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsOpenGeneric(System.Type)">
            <summary>Returns true if type if open generic: contains at list one open generic parameter. Could be
            generic type definition as well.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericDefinitionOrNull(System.Type)">
            <summary>Returns generic type definition if type is generic and null otherwise.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamsAndArgs(System.Type)">
            <summary>Returns generic type parameters and arguments in order they specified. If type is not generic, returns empty array.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetGenericParamConstraints(System.Type)">
            <summary>Returns array of interface and base class constraints for provider generic parameter type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetArrayElementTypeOrNull(System.Type)">
            <summary>If type is array returns is element type, otherwise returns null.</summary>
            <param name="type">Source type.</param> <returns>Array element type or null.</returns>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetBaseType(System.Type)">
            <summary>Return base type or null, if not exist (the case for only for object type).</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPublicOrNestedPublic(System.Type)">
            <summary>Checks if type is public or nested public in public type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClass(System.Type)">
            <summary>Returns true if type is class.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsValueType(System.Type)">
            <summary>Returns true if type is value type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsInterface(System.Type)">
            <summary>Returns true if type is interface.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAbstract(System.Type)">
            <summary>Returns true if type if abstract or interface.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Type)">
            <summary>Returns true if type is static.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsEnum(System.Type)">
            <summary>Returns true if type is enum type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.HasConversionOperatorTo(System.Type,System.Type)">
            <summary>Returns true if type can be casted with conversion operators.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSourceConversionOperatorToTarget(System.Type,System.Type)">
            Returns `target source.op_(Explicit|Implicit)(source)` or null if not found
        </member>
        <member name="M:DryIoc.ReflectionTools.GetTargetConversionOperatorFromSource(System.Type,System.Type)">
            Returns `target target.op_(Explicit|Implicit)(source)` or null if not found
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo(System.Type,System.Type)">
            <summary>Returns true if type is assignable to <paramref name="other"/> type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsAssignableTo``1(System.Type)">
            <summary>Returns true if type is assignable to <typeparamref name="T"/> type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsTypeOf(System.Type,System.Object)">
            <summary>Returns true if type of <paramref name="obj"/> is assignable to source <paramref name="type"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsPrimitive(System.Type,System.Boolean)">
            <summary>Returns true if provided type IsPrimitive in .Net terms, or enum, or string,
            or array of primitives if <paramref name="orArrayOfPrimitives"/> is true.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Type,System.Type,System.Boolean)">
            <summary>Returns all attributes defined on <paramref name="type"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMembers``1(System.Type,System.Func{System.Reflection.TypeInfo,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>Recursive method to enumerate all input type and its base types for specific details.
            Details are returned by <paramref name="getMembers"/> delegate.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.PublicConstructors(System.Type)">
            <summary>Returns all public instance constructors for the type</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.PublicAndInternalConstructors(System.Type)">
            <summary>Returns all public instance constructors for the type</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Constructors(System.Type,System.Boolean,System.Boolean)">
            <summary>Enumerates all constructors from input type.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Boolean,System.Type[])">
            <summary>Searches and returns constructor by its signature.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetConstructorOrNull(System.Type,System.Type[])">
            <summary>Searches and returns constructor by its signature.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Constructor(System.Type,System.Type[])">
            <summary>Searches and returns constructor by its signature, or throws if not found</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleConstructorOrNull(System.Type,System.Boolean)">
            <summary>Returns single constructor otherwise (if no constructor or more than one) returns null.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.SingleConstructor(System.Type,System.Boolean)">
            <summary>Returns single constructor otherwise (if no or more than one) throws an exception</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetSingleMethodOrNull(System.Type,System.String,System.Boolean)">
            <summary>Looks up for single declared method with the specified name. Returns null if method is not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.SingleMethod(System.Type,System.String,System.Boolean)">
            <summary>Looks for single declared (not inherited) method by name, and throws if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Method(System.Type,System.String,System.Type[])">
            <summary>Looks up for method with and specified parameter types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetMethodOrNull(System.Type,System.String,System.Type[])">
            <summary>Looks up for method with and specified parameter types.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Property(System.Type,System.String,System.Boolean)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetPropertyOrNull(System.Type,System.String,System.Boolean)">
            <summary>Returns property by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.Field(System.Type,System.String,System.Boolean)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetFieldOrNull(System.Type,System.String,System.Boolean)">
            <summary>Returns field by name, including inherited. Or null if not found.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAssembly(System.Type)">
            <summary>Returns type assembly.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsExplicitlyImplemented(System.Reflection.PropertyInfo)">
            <summary>Is <c>true</c> for interface declared property explicitly implemented, e.g. <c>IInterface.Prop</c></summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.MemberInfo)">
            <summary>Returns true if member is static, otherwise returns false.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsStatic(System.Reflection.PropertyInfo,System.Boolean)">
            Find if property is static
        </member>
        <member name="M:DryIoc.ReflectionTools.GetReturnTypeOrDefault(System.Reflection.MemberInfo)">
            <summary>Return either <see cref="P:System.Reflection.PropertyInfo.PropertyType"/>, or <see cref="P:System.Reflection.FieldInfo.FieldType"/>, 
            <see cref="P:System.Reflection.MethodInfo.ReturnType"/>.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsBackingField(System.Reflection.FieldInfo)">
            <summary>Returns true if field is backing field for property.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsIndexer(System.Reflection.PropertyInfo)">
            <summary>Returns true if property is indexer: aka this[].</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.IsClosureType(System.Type)">
            <summary>Returns true if type is generated type of hoisted closure.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for the member/method.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetAttributes(System.Reflection.ParameterInfo,System.Type,System.Boolean)">
            <summary>Returns attributes defined for parameter.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetLoadedTypes(System.Reflection.Assembly)">
            <summary>Get types from assembly that are loaded successfully.
            Hacks the <see cref="T:System.Reflection.ReflectionTypeLoadException"/>to get failing to load types metadata.</summary>
        </member>
        <member name="M:DryIoc.ReflectionTools.GetDefaultValueExpression(System.Type)">
            <summary>Creates default(T) expression for provided <paramref name="type"/>.</summary>
        </member>
        <member name="T:DryIoc.PrintTools">
            <summary>Provides pretty printing/debug view for number of types.</summary>
        </member>
        <member name="F:DryIoc.PrintTools.DefaultItemSeparator">
            <summary>Default separator used for printing enumerable.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Object,System.String,System.String,System.Func{System.Type,System.String})">
            <summary>Prints input object by using corresponding Print methods for know types.</summary>
            <param name="s">Builder to append output to.</param> <param name="x">Object to print.</param>
            <param name="quote">(optional) Quote to use for quoting string object.</param>
            <param name="itemSeparator">(optional) Separator for enumerable.</param>
            <param name="getTypeName">(optional) Custom type printing policy.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.String,System.String)">
            <summary>Appends string to string builder quoting with <paramref name="quote"/> if provided.</summary>
            <param name="s">String builder to append string to.</param> <param name="str">String to print.</param>
            <param name="quote">(optional) Quote to add before and after string.</param>
            <returns>String builder with appended string.</returns>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Collections.IEnumerable,System.String,System.Action{System.Text.StringBuilder,System.Object})">
            <summary>Prints enumerable by using corresponding Print method for known item type.</summary>
            <param name="s">String builder to append output to.</param>
            <param name="items">Items to print.</param>
            <param name="separator">(optional) Custom separator if provided.</param>
            <param name="printItem">(optional) Custom item printer if provided.</param>
            <returns>String builder with appended output.</returns>
        </member>
        <member name="F:DryIoc.PrintTools.GetTypeNameDefault">
            <summary>Default delegate to print Type details: by default prints Type FullName and
            skips namespace if it start with "System."</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Text.StringBuilder,System.Type,System.Func{System.Type,System.String})">
            <summary>Pretty prints the <paramref name="type"/> in proper C# representation.
            <paramref name="getTypeName"/>Allows to specify if you want Name instead of FullName.</summary>
        </member>
        <member name="M:DryIoc.PrintTools.Print(System.Type,System.Func{System.Type,System.String})">
            <summary>Pretty-prints the type</summary>
        </member>
        <member name="T:DryIoc.Portable">
            <summary>Ports some methods from .Net 4.0/4.5</summary>
        </member>
        <member name="M:DryIoc.Portable.GetAssemblyTypes(System.Reflection.Assembly)">
            <summary>Portable version of Assembly.GetTypes or Assembly.DefinedTypes.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetGetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetGetMethod.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetSetMethodOrNull(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Portable version of PropertyInfo.GetSetMethod.</summary>
        </member>
        <member name="M:DryIoc.Portable.GetCurrentManagedThreadID">
            <summary>Returns managed Thread ID either from Environment or Thread.CurrentThread whichever is available.</summary>
        </member>
        <member name="T:DryIoc.AsyncExecutionFlowScopeContext">
            <summary>Stores scopes propagating through async-await boundaries.</summary>
        </member>
        <member name="F:DryIoc.AsyncExecutionFlowScopeContext.ScopeContextName">
            <summary>Statically known name of root scope in this context.</summary>
        </member>
        <member name="F:DryIoc.AsyncExecutionFlowScopeContext.Default">
            It is fine to use a default instance, cause the async local scope are actually a static one
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.GetCurrentOrDefault">
            <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
            <returns>Current scope or null.</returns>
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.SetCurrent(DryIoc.SetCurrentScopeHandler)">
            <summary>Changes current scope using provided delegate. Delegate receives current scope as input and  should return new current scope.</summary>
            <param name="changeCurrentScope">Delegate to change the scope.</param>
            <remarks>Important: <paramref name="changeCurrentScope"/> may be called multiple times in concurrent environment.
            Make it predictable by removing any side effects.</remarks>
            <returns>New current scope. It is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
        </member>
        <member name="M:DryIoc.AsyncExecutionFlowScopeContext.Dispose">
            <summary>Nothing to dispose.</summary>
        </member>
        <member name="T:DryIoc.Messages.IMessage`1">
            Base type for messages
        </member>
        <member name="T:DryIoc.Messages.EmptyResponse">
            Type for an empty response
        </member>
        <member name="F:DryIoc.Messages.EmptyResponse.Value">
            Single value
        </member>
        <member name="F:DryIoc.Messages.EmptyResponse.Task">
            Single completed task
        </member>
        <member name="T:DryIoc.Messages.IMessageHandler`2">
            Base message handler
        </member>
        <member name="M:DryIoc.Messages.IMessageHandler`2.Handle(`0,System.Threading.CancellationToken)">
            Generic handler
        </member>
        <member name="T:DryIoc.Messages.IMessageHandler`1">
            Base message handler for message with empty response
        </member>
        <member name="T:DryIoc.Messages.IMessageMiddleware`2">
            Message handler middleware to handle the message and pass the result to the next middleware
        </member>
        <member name="M:DryIoc.Messages.IMessageMiddleware`2.Handle(`0,System.Threading.CancellationToken,System.Func{System.Threading.Tasks.Task{`1}})">
            Handles message and passes to the next middleware
        </member>
        <member name="T:DryIoc.Messages.AsyncMessageHandler`2">
            Base class for implementing async handlers
        </member>
        <member name="M:DryIoc.Messages.AsyncMessageHandler`2.Handle(`0,System.Threading.CancellationToken)">
            Base method to implement in your inheritor
        </member>
        <member name="T:DryIoc.Messages.MiddlewareMessageHandler`2">
            Sequential middleware type of message handler decorator
        </member>
        <member name="M:DryIoc.Messages.MiddlewareMessageHandler`2.#ctor(DryIoc.Messages.IMessageHandler{`0,`1},System.Collections.Generic.IEnumerable{DryIoc.Messages.IMessageMiddleware{`0,`1}})">
            Decorates message handler with optional middlewares
        </member>
        <member name="M:DryIoc.Messages.MiddlewareMessageHandler`2.Handle(`0,System.Threading.CancellationToken)">
            Composes middlewares with handler
        </member>
        <member name="T:DryIoc.Messages.IMessage">
            Message with empty response
        </member>
        <member name="T:DryIoc.Messages.BroadcastMessageHandler`1">
            Broadcasting type of message handler decorator
        </member>
        <member name="M:DryIoc.Messages.BroadcastMessageHandler`1.#ctor(System.Collections.Generic.IEnumerable{DryIoc.Messages.IMessageHandler{`0,DryIoc.Messages.EmptyResponse}})">
            Constructs the hub with the handler and optional middlewares
        </member>
        <member name="M:DryIoc.Messages.BroadcastMessageHandler`1.Handle(`0,System.Threading.CancellationToken)">
            Composes middlewares with handler
        </member>
        <member name="T:DryIoc.Messages.MessageMediator">
            A subject
        </member>
        <member name="M:DryIoc.Messages.MessageMediator.#ctor(DryIoc.IResolver)">
            Constructs with resolver
        </member>
        <member name="M:DryIoc.Messages.MessageMediator.Send``2(``0,System.Threading.CancellationToken)">
            Sends message with response to resolved handlers
        </member>
        <member name="M:DryIoc.Messages.MessageMediator.Send``1(``0,System.Threading.CancellationToken)">
            Sends message with empty response to resolved handlers
        </member>
        <member name="T:DryIoc.WebApi.DryIocWebApi">
            <summary>WebApi DI bootstrapper with DryIoc.</summary>
        </member>
        <member name="M:DryIoc.WebApi.DryIocWebApi.WithWebApi(DryIoc.IContainer,System.Web.Http.HttpConfiguration,System.Collections.Generic.IEnumerable{System.Reflection.Assembly},DryIoc.IScopeContext,System.Func{System.Type,System.Boolean})">
            <summary>Configures container to work with ASP.NET WepAPI by: 
            setting container scope context to <see cref="T:DryIoc.AsyncExecutionFlowScopeContext"/> (if scope context is not set already),
            registering HTTP controllers, setting filter provider and dependency resolver.</summary>
            <param name="container">Original container.</param> <param name="config">Http configuration.</param>
            <param name="controllerAssemblies">(optional) Assemblies to look for controllers, default is ExecutingAssembly.</param>
            <param name="scopeContext">(optional) Specific scope context to use, by default method sets
            <see cref="T:DryIoc.AsyncExecutionFlowScopeContext"/>, only if container does not have context specified already.</param>
            <param name="throwIfUnresolved">(optional) Instructs DryIoc to throw exception
            for unresolved type instead of fallback to default Resolver.</param>
            <returns>New container.</returns>
        </member>
        <member name="M:DryIoc.WebApi.DryIocWebApi.RegisterWebApiControllers(DryIoc.IContainer,System.Web.Http.HttpConfiguration,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>Registers controllers found in provided assemblies with <see cref="F:DryIoc.Reuse.InWebRequest"/>.</summary>
            <param name="container">Container.</param>
            <param name="config">Http configuration.</param>
            <param name="assemblies">Assemblies to look for controllers.</param>
        </member>
        <member name="M:DryIoc.WebApi.DryIocWebApi.IsController(System.Type)">
            <summary>Helps to find if type is controller type.</summary>
            <param name="type">Type to check.</param>
            <returns>True if controller type</returns>
        </member>
        <member name="M:DryIoc.WebApi.DryIocWebApi.SetFilterProvider(DryIoc.IContainer,System.Web.Http.Controllers.ServicesContainer)">
            <summary>Replaces all filter providers in services with <see cref="T:DryIoc.WebApi.DryIocFilterProvider"/>, and registers it in container.</summary>
            <param name="container">DryIoc container.</param> <param name="services">Services</param>
        </member>
        <member name="M:DryIoc.WebApi.DryIocWebApi.InsertRegisterRequestMessageHandler(System.Web.Http.HttpConfiguration)">
            <summary>Inserts DryIoc delegating request handler into message handlers.</summary>
            <param name="config">Current configuration.</param>
        </member>
        <member name="T:DryIoc.WebApi.DryIocDependencyResolver">
            <summary>Resolve based on DryIoc container.</summary>
        </member>
        <member name="F:DryIoc.WebApi.DryIocDependencyResolver.Container">
            <summary>Original DryIoc container.</summary>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyResolver.#ctor(DryIoc.IContainer,System.Func{System.Type,System.Boolean})">
            <summary>Creates dependency resolver.</summary>
            <param name="container">Container.</param>
            <param name="throwIfUnresolved">(optional) Instructs DryIoc to throw exception
            for unresolved type instead of fallback to default Resolver.</param>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyResolver.Dispose">
            <summary>Disposes container.</summary>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyResolver.GetService(System.Type)">
            <summary>Retrieves a service from the scope or null if unable to resolve service.</summary>
            <returns>The retrieved service.</returns> <param name="serviceType">The service to be retrieved.</param>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyResolver.GetServices(System.Type)">
            <summary>Retrieves a collection of services from the scope or empty collection.</summary>
            <returns>The retrieved collection of services.</returns>
            <param name="serviceType">The collection of services to be retrieved.</param>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyResolver.BeginScope">
            <summary>Opens scope from underlying container.</summary>
            <returns>Opened scope wrapped in dependency scope.</returns>
        </member>
        <member name="T:DryIoc.WebApi.DryIocDependencyScope">
            <summary>Dependency scope adapter to scoped DryIoc container.</summary>
        </member>
        <member name="F:DryIoc.WebApi.DryIocDependencyScope.ScopedContainer">
            <summary>Wrapped DryIoc container.</summary>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyScope.#ctor(DryIoc.IResolverContext,System.Func{System.Type,System.Boolean})">
            <summary>Adapts input container.</summary>
            <param name="scopedContainer">Container returned by OpenScope method.</param>
            <param name="throwIfUnresolved">(optional) Instructs DryIoc to throw exception
            for unresolved type instead of fallback to default Resolver.</param>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyScope.Dispose">
            <summary>Disposed underlying scoped container.</summary>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyScope.GetService(System.Type)">
            <summary>Retrieves a service from the scope or returns null if not resolved.</summary>
        </member>
        <member name="M:DryIoc.WebApi.DryIocDependencyScope.GetServices(System.Type)">
            <summary>Retrieves a collection of services from the scope or empty collection.</summary>
            <returns>The retrieved collection of services.</returns>
            <param name="serviceType">The collection of services to be retrieved.</param>
        </member>
        <member name="T:DryIoc.WebApi.DryIocFilterProvider">
            <summary>Aggregated filter provider.</summary>
        </member>
        <member name="M:DryIoc.WebApi.DryIocFilterProvider.#ctor(DryIoc.IContainer,System.Collections.Generic.IEnumerable{System.Web.Http.Filters.IFilterProvider})">
            <summary>Creates filter provider.</summary>
            <param name="container"></param> <param name="providers"></param>
        </member>
        <member name="M:DryIoc.WebApi.DryIocFilterProvider.GetFilters(System.Web.Http.HttpConfiguration,System.Web.Http.Controllers.HttpActionDescriptor)">
            <summary> Returns an enumeration of filters. </summary>
            <returns> An enumeration of filters. </returns>
            <param name="configuration">The HTTP configuration.</param><param name="actionDescriptor">The action descriptor.</param>
        </member>
        <member name="T:DryIoc.WebApi.RegisterRequestMessageHandler">
            <summary>Registers current <see cref="T:System.Net.Http.HttpRequestMessage"/> into dependency scope.</summary>
        </member>
        <member name="M:DryIoc.WebApi.RegisterRequestMessageHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)">
            <summary>Registers request into dependency scope and sends proceed the pipeline.</summary> 
            <param name="request">The HTTP request message to send to the server.</param>
            <param name="cancellationToken">A cancellation token to cancel operation.</param>
            <returns>The task object representing the asynchronous operation.</returns>
        </member>
        <member name="M:DryIoc.WebApi.RegisterRequestMessageHandler.RegisterInDependencyScope(System.Net.Http.HttpRequestMessage)">
            <summary>Registers request into current dependency scope.</summary>
        </member>
        <member name="T:FastExpressionCompiler.LightExpression.Expression">
            <summary>Facade for constructing Expression.</summary>
        </member>
        <member name="P:FastExpressionCompiler.LightExpression.Expression.NodeType">
            <summary>Expression node type.</summary>
        </member>
        <member name="P:FastExpressionCompiler.LightExpression.Expression.Type">
            <summary>All expressions should have a Type.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.Expression.ToExpression">
            <summary>Converts back to respective System Expression, so you may Compile it by usual means.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.Expression.ToString">
            <summary>Converts to Expression and outputs its as string</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.Expression.Reduce">
            <summary>Reduces the Expression to simple ones</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.Expression.MemberInit(FastExpressionCompiler.LightExpression.Expression,FastExpressionCompiler.LightExpression.MemberBinding[])">
            <summary>Does not present in System Expression. Enables member assignment on existing instance expression.</summary>
        </member>
        <member name="T:FastExpressionCompiler.LightExpression.IndexExpression">
            <summary>For indexer property or array access.</summary>
        </member>
        <member name="T:FastExpressionCompiler.LightExpression.ExpressionCompiler">
            <summary>Compiles expression to delegate ~20 times faster than Expression.Compile.
            Partial to extend with your things when used as source file.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``1(FastExpressionCompiler.LightExpression.LambdaExpression,System.Boolean)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast(FastExpressionCompiler.LightExpression.LambdaExpression,System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileSys``1(FastExpressionCompiler.LightExpression.Expression{``0})">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileSys(FastExpressionCompiler.LightExpression.LambdaExpression)">
            <summary>Unifies Compile for System.Linq.Expressions and FEC.LightExpression</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``1(FastExpressionCompiler.LightExpression.Expression{``0},System.Boolean)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``1(FastExpressionCompiler.LightExpression.Expression{System.Func{``0}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``2(FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``3(FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2}},System.Boolean)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``4(FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2,``3}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``5(FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2,``3,``4}},System.Boolean)">
            <summary>Compiles lambda expression to TDelegate type. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``6(FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2,``3,``4,``5}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``7(FastExpressionCompiler.LightExpression.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast(FastExpressionCompiler.LightExpression.Expression{System.Action},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``1(FastExpressionCompiler.LightExpression.Expression{System.Action{``0}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``2(FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``3(FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1,``2}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``4(FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1,``2,``3}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``5(FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1,``2,``3,``4}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.CompileFast``6(FastExpressionCompiler.LightExpression.Expression{System.Action{``0,``1,``2,``3,``4,``5}},System.Boolean)">
            <summary>Compiles lambda expression to delegate. Use ifFastFailedReturnNull parameter to Not fallback to Expression.Compile, useful for testing.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompile``1(FastExpressionCompiler.LightExpression.LambdaExpression)">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/></summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompileWithPreCreatedClosure``1(FastExpressionCompiler.LightExpression.LambdaExpression,System.Object,FastExpressionCompiler.LightExpression.ConstantExpression[])">
            <summary>Tries to compile lambda expression to <typeparamref name="TDelegate"/> 
            with the provided closure object and constant expressions (or lack there of) -
            Constant expression should be the in order of Fields in closure object!
            Note 1: Use it on your own risk - FEC won't verify the expression is compile-able with passed closure, it is up to you!
            Note 2: The expression with NESTED LAMBDA IS NOT SUPPORTED!
            Note 3: `Label` and `GoTo` are not supported in this case, because they need first round to collect out-of-order labels</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompileWithoutClosure``1(FastExpressionCompiler.LightExpression.LambdaExpression)">
            <summary>Tries to compile expression to "static" delegate, skipping the step of collecting the closure object.</summary>
        </member>
        <member name="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.TryCompile``1(FastExpressionCompiler.LightExpression.Expression,System.Collections.Generic.IReadOnlyList{FastExpressionCompiler.LightExpression.ParameterExpression},System.Type[],System.Type)">
            <summary>Compiles expression to delegate by emitting the IL. 
            If sub-expressions are not supported by emitter, then the method returns null.
            The usage should be calling the method, if result is null then calling the Expression.Compile.</summary>
        </member>
        <member name="T:FastExpressionCompiler.LightExpression.ExpressionCompiler.EmittingVisitor">
            <summary>Supports emitting of selected expressions, e.g. lambdaExpr are not supported yet.
            When emitter find not supported expression it will return false from <see cref="M:FastExpressionCompiler.LightExpression.ExpressionCompiler.EmittingVisitor.TryEmit(FastExpressionCompiler.LightExpression.Expression,System.Collections.Generic.IReadOnlyList{FastExpressionCompiler.LightExpression.ParameterExpression},System.Reflection.Emit.ILGenerator,FastExpressionCompiler.LightExpression.ExpressionCompiler.ClosureInfo@,FastExpressionCompiler.LightExpression.ExpressionCompiler.ParentFlags,System.Int32)"/>, so I could fallback
            to normal and slow Expression.Compile.</summary>
        </member>
        <member name="T:ImTools.Fun">
            <summary>Helpers for functional composition</summary>
        </member>
        <member name="M:ImTools.Fun.Always``1(``0)">
            <summary>Always a true condition.</summary>
        </member>
        <member name="M:ImTools.Fun.Id``1(``0)">
            <summary>Identity function returning passed argument as result.</summary>
        </member>
        <member name="M:ImTools.Fun.To``2(``0,System.Func{``0,``1})">
            <summary>Piping</summary>
        </member>
        <member name="M:ImTools.Fun.Do``1(``0,System.Action{``0})">
            <summary>Piping</summary>
        </member>
        <member name="M:ImTools.Fun.ToFunc``2(``1,``0)">
            Lift argument to Func without allocations ignoring the first argument.
            For example if you have `Func{T, R} = _ => instance`,
            you may rewrite it without allocations as `instance.ToFunc{A, R}` 
        </member>
        <member name="T:ImTools.Lazy">
            <summary>Helpers for lazy instantiations</summary>
        </member>
        <member name="M:ImTools.Lazy.Of``1(System.Func{``0})">
            <summary>Provides result type inference for creation of lazy.</summary>
        </member>
        <member name="T:ImTools.ArrayTools">
            <summary>Methods to work with immutable arrays and some sugar.</summary>
        </member>
        <member name="M:ImTools.ArrayTools.Empty``1">
            <summary>Returns singleton empty array of provided type.</summary> 
            <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.One``1(``0)">
            <summary>Wraps item in array.</summary>
        </member>
        <member name="M:ImTools.ArrayTools.IsNullOrEmpty``1(``0[])">
            <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.EmptyIfNull``1(``0[])">
            <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
        </member>
        <member name="M:ImTools.ArrayTools.ToArrayOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.
        </member>
        <member name="M:ImTools.ArrayTools.ToListOrSelf``1(System.Collections.Generic.IEnumerable{``0})">
            Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.
        </member>
        <member name="M:ImTools.ArrayTools.Append``1(``0[],``0[])">
            <summary>Returns new array consisting from all items from source array then all items from added array.
            If source is null or empty, then added array will be returned.
            If added is null or empty, then source will be returned.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array with leading items.</param>
            <param name="added">Array with following items.</param>
            <returns>New array with items of source and added arrays.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Performant concat of enumerables in case of arrays.
            But performance will degrade if you use Concat().Where().</summary>
            <typeparam name="T">Type of item.</typeparam>
            <param name="source">goes first.</param>
            <param name="other">appended to source.</param>
            <returns>empty array or concat of source and other.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.AppendOrUpdate``1(``0[],``0,System.Int32)">
            <summary>Returns new array with <paramref name="value"/> appended, 
            or <paramref name="value"/> at <paramref name="index"/>, if specified.
            If source array could be null or empty, then single value item array will be created despite any index.</summary>
            <typeparam name="T">Array item type.</typeparam>
            <param name="source">Array to append value to.</param>
            <param name="value">Value to append.</param>
            <param name="index">(optional) Index of value to update.</param>
            <returns>New array with appended or updated value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOf``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
            then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
            <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOf``2(``0[],``1,System.Func{``1,``0,System.Boolean})">
            Minimizes the allocations for closure in predicate lambda with the provided <paramref name="state"/>
        </member>
        <member name="M:ImTools.ArrayTools.IndexOf``1(``0[],``0)">
            <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
            <typeparam name="T">Type of array items.</typeparam>
            <param name="source">Source array: if null or empty, then method will return -1.</param>
            <param name="value">Value to look up.</param>
            <returns>Index of item equal to value, or -1 item is not found.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.RemoveAt``1(``0[],System.Int32)">
            <summary>Produces new array without item at specified <paramref name="index"/>. 
            Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
            <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Remove``1(``0[],``0)">
            <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
            <typeparam name="T">Type of array item.</typeparam>
            <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
            <returns>New array with value removed or original array if value is not found.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.FindFirst``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
            <typeparam name="T">item type</typeparam>
            <param name="source">items collection to search</param>
            <param name="predicate">condition to evaluate for each item.</param>
            <returns>First item matching condition or default value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.FindFirst``2(``0[],``1,System.Func{``1,``0,System.Boolean})">
            Version of FindFirst with the fixed state used by predicate to prevent allocations by predicate lambda closure
        </member>
        <member name="M:ImTools.ArrayTools.FindFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
            <typeparam name="T">item type</typeparam>
            <param name="source">items collection to search</param>
            <param name="predicate">condition to evaluate for each item.</param>
            <returns>First item matching condition or default value.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.SingleOrDefaultIfMany``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns element if collection consist on single element, otherwise returns default value.
            It does not throw for collection with many elements</summary>
        </member>
        <member name="M:ImTools.ArrayTools.ForEach``1(``0[],System.Action{``0})">
            <summary>Does <paramref name="action"/> for each item</summary>
        </member>
        <member name="M:ImTools.ArrayTools.AppendTo``1(``0[],System.Int32,System.Int32,``0[])">
            Appends source to results
        </member>
        <member name="M:ImTools.ArrayTools.Match``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
            <typeparam name="T">Type of source items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>
            <returns>New array if some items are filter out. Empty array if all items are filtered out. Original array otherwise.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``2(``0[],``1,System.Func{``1,``0,System.Boolean})">
            Match with the additional state to use in <paramref name="condition"/> to minimize the allocations in <paramref name="condition"/> lambda closure 
        </member>
        <member name="M:ImTools.ArrayTools.Match``2(``0[],System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
            It returns source array and does Not create new one if all items match the condition.</summary>
            <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param> <param name="map">Converter from source to result item.</param>
            <returns>New array of result items.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``3(``0[],``1,System.Func{``1,``0,System.Boolean},System.Func{``1,``0,``2})">
            Match with the additional state to use in <paramref name="condition"/> and <paramref name="map"/> to minimize the allocations in <paramref name="condition"/> lambda closure 
        </member>
        <member name="M:ImTools.ArrayTools.Map``2(``0[],System.Func{``0,``1})">
            <summary>Maps all items from source to result array.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Map``3(``0[],``1,System.Func{``1,``0,``2})">
            Map with additional state to use in <paramref name="map"/> to minimize allocations in <paramref name="map"/> lambda closure 
        </member>
        <member name="M:ImTools.ArrayTools.Map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Maps all items from source to result collection. 
            If possible uses fast array Map otherwise Enumerable.Select.</summary>
            <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
            <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
            <returns>Converted items</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
            <typeparam name="T">Type of source items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>
            <returns>Result items, may be an array.</returns>
        </member>
        <member name="M:ImTools.ArrayTools.Match``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>If <paramref name="source"/> is array uses more effective Match for array,
            otherwise just calls Where, Select</summary>
            <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
            <param name="source">If null, the null will be returned.</param>
            <param name="condition">Condition to keep items.</param>  <param name="map">Converter from source to result item.</param>
            <returns>Result items, may be an array.</returns>
        </member>
        <member name="T:ImTools.Ref`1">
            <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0})"/>.</summary>
            <typeparam name="T">Type of object to wrap.</typeparam>
        </member>
        <member name="P:ImTools.Ref`1.Value">
            <summary>Gets the wrapped value.</summary>
        </member>
        <member name="M:ImTools.Ref`1.#ctor(`0)">
            <summary>Creates ref to object, optionally with initial value provided.</summary>
            <param name="initialValue">(optional) Initial value.</param>
        </member>
        <member name="M:ImTools.Ref`1.Swap(System.Func{`0,`0})">
            <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0})"/> for details.</summary>
            <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
            <returns>Returns old object value the same way as <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/></returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:ImTools.Ref`1.Swap``1(``0,System.Func{``0,`0,`0})">
            Option without allocation for capturing `a` in closure of `getNewValue`
        </member>
        <member name="M:ImTools.Ref`1.Swap``2(``0,``1,System.Func{``0,``1,`0,`0})">
            Option without allocation for capturing `a` and `b` in closure of `getNewValue`
        </member>
        <member name="M:ImTools.Ref`1.Swap(`0)">
            <summary>Just sets new value ignoring any intermingled changes.</summary>
            <param name="newValue"></param> <returns>old value</returns>
        </member>
        <member name="M:ImTools.Ref`1.TrySwapIfStillCurrent(`0,`0)">
            <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
            <param name="currentValue"></param> <param name="newValue"></param>
            <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
            <example><c>[!CDATA[
            var value = SomeRef.Value;
            if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
                SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
            ]]</c></example>
        </member>
        <member name="T:ImTools.Ref">
            <summary>Provides optimistic-concurrency consistent <see cref="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0})"/> operation.</summary>
        </member>
        <member name="M:ImTools.Ref.Of``1(``0)">
            <summary>Factory for <see cref="T:ImTools.Ref`1"/> with type of value inference.</summary>
            <typeparam name="T">Type of value to wrap.</typeparam>
            <param name="value">Initial value to wrap.</param>
            <returns>New ref.</returns>
        </member>
        <member name="M:ImTools.Ref.NewRef``1(ImTools.Ref{``0})">
            <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
            <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        </member>
        <member name="M:ImTools.Ref.Swap``1(``0@,System.Func{``0,``0})">
            <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
            Second, it checks that original value is not changed. 
            If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
            <typeparam name="T">Type of value to swap.</typeparam>
            <param name="value">Reference to change to new value</param>
            <param name="getNewValue">Delegate to get value from old one.</param>
            <returns>Old/original value. By analogy with <see cref="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)"/>.</returns>
            <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        </member>
        <member name="M:ImTools.Ref.Swap``2(``1@,``0,System.Func{``0,``1,``1})">
            Option without allocation for capturing `a` in closure of `getNewValue`
        </member>
        <member name="M:ImTools.Ref.Swap``3(``2@,``0,``1,System.Func{``0,``1,``2,``2})">
            Option without allocation for capturing `a` and `b` in closure of `getNewValue`
        </member>
        <member name="T:ImTools.IPrintable">
            <summary>Printable string via provided printer </summary>
        </member>
        <member name="M:ImTools.IPrintable.Print(System.Text.StringBuilder,System.Func{System.Text.StringBuilder,System.Object,System.Text.StringBuilder})">
            <summary>Print to the provided string builder via the provided printer.</summary>
        </member>
        <member name="T:ImTools.Hasher">
            <summary>Produces good enough hash codes for the fields</summary>
        </member>
        <member name="M:ImTools.Hasher.Combine``2(``0,``1)">
            <summary>Combines hashes of two fields</summary>
        </member>
        <member name="M:ImTools.Hasher.Combine(System.Int32,System.Int32)">
            <summary>Inspired by System.Tuple.CombineHashCodes</summary>
        </member>
        <member name="T:ImTools.KV`2">
            <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
            which is different from System value type <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            In addition provides <see cref="M:ImTools.KV`2.Equals(System.Object)"/> and <see cref="M:ImTools.KV`2.GetHashCode"/> implementations.</summary>
            <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
        </member>
        <member name="F:ImTools.KV`2.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:ImTools.KV`2.Value">
            <summary>Value.</summary>
        </member>
        <member name="M:ImTools.KV`2.#ctor(`0,`1)">
            <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
            <param name="key">key.</param><param name="value">value.</param>
        </member>
        <member name="M:ImTools.KV`2.Print(System.Text.StringBuilder,System.Func{System.Text.StringBuilder,System.Object,System.Text.StringBuilder})">
            <inheritdoc />
        </member>
        <member name="M:ImTools.KV`2.ToString">
            <summary>Creates nice string view.</summary><returns>String representation.</returns>
        </member>
        <member name="M:ImTools.KV`2.Equals(System.Object)">
            <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
        </member>
        <member name="M:ImTools.KV`2.GetHashCode">
            <summary>Combines key and value hash code</summary>
        </member>
        <member name="T:ImTools.KV">
            <summary>Helpers for <see cref="T:ImTools.KV`2"/>.</summary>
        </member>
        <member name="M:ImTools.KV.Of``2(``0,``1)">
            <summary>Creates the key value pair.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="key">Key</param> <param name="value">Value</param> <returns>New pair.</returns>
        </member>
        <member name="M:ImTools.KV.WithKey``2(ImTools.KV{``0,``1},``0)">
            <summary>Creates the new pair with new key and old value.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="source">Source value</param> <param name="key">New key</param> <returns>New pair</returns>
        </member>
        <member name="M:ImTools.KV.WithValue``2(ImTools.KV{``0,``1},``1)">
            <summary>Creates the new pair with old key and new value.</summary>
            <typeparam name="K">Key type</typeparam> <typeparam name="V">Value type</typeparam>
            <param name="source">Source value</param> <param name="value">New value.</param> <returns>New pair</returns>
        </member>
        <member name="T:ImTools.KeyValuePair">
            <summary>Simple helper for creation of the pair of two parts.</summary>
        </member>
        <member name="M:ImTools.KeyValuePair.Pair``2(``0,``1)">
            <summary>Pairs key with value.</summary>
        </member>
        <member name="T:ImTools.Opt`1">
            <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.</summary>
        </member>
        <member name="M:ImTools.Opt`1.op_Implicit(`0)~ImTools.Opt{`0}">
            <summary>Allows to transparently convert parameter argument to opt structure.</summary>
        </member>
        <member name="F:ImTools.Opt`1.Value">
            <summary>Argument value.</summary>
        </member>
        <member name="F:ImTools.Opt`1.HasValue">
            <summary>Indicates that value is provided.</summary>
        </member>
        <member name="M:ImTools.Opt`1.#ctor(`0)">
            <summary>Wraps passed value in structure. Sets the flag that value is present.</summary>
        </member>
        <member name="M:ImTools.Opt`1.OrDefault(`0)">
            <summary>Helper to get value or default value if value is not present.</summary>
        </member>
        <member name="T:ImTools.ImList`1">
            <summary>Immutable list - simplest linked list with Head and Rest.</summary>
            <typeparam name="T">Type of the item.</typeparam>
        </member>
        <member name="F:ImTools.ImList`1.Empty">
            <summary>Empty list to Push to.</summary>
        </member>
        <member name="P:ImTools.ImList`1.IsEmpty">
            <summary>True for empty list.</summary>
        </member>
        <member name="F:ImTools.ImList`1.Head">
            <summary>First value in a list.</summary>
        </member>
        <member name="F:ImTools.ImList`1.Tail">
            <summary>The rest of values or Empty if list has a single value.</summary>
        </member>
        <member name="M:ImTools.ImList`1.Prep(`0)">
            <summary>Prepends new value and returns new list.</summary>
            <param name="head">New first value.</param>
            <returns>List with the new head.</returns>
        </member>
        <member name="M:ImTools.ImList`1.Enumerate">
            <summary>Enumerates the list.</summary>
            <returns>Each item in turn.</returns>
        </member>
        <member name="T:ImTools.ImList">
            <summary>Extension methods providing basic operations on a list.</summary>
        </member>
        <member name="M:ImTools.ImList.To``2(ImTools.ImList{``0},``1,System.Func{``0,``1,``1})">
            <summary>This a basically a Fold function, to address needs in Map, Filter, Reduce.</summary>
            <typeparam name="T">Type of list item.</typeparam>
            <typeparam name="R">Type of result.</typeparam>
            <param name="source">List to fold.</param>
            <param name="initialValue">From were to start.</param>
            <param name="collect">Collects list item into result</param>
            <returns>Return result or <paramref name="initialValue"/> for empty list.</returns>
        </member>
        <member name="M:ImTools.ImList.To``2(ImTools.ImList{``0},``1,System.Func{``0,System.Int32,``1,``1})">
            <summary>Form of fold function with element index for convenience.</summary>
            <typeparam name="T">Type of list item.</typeparam>
            <typeparam name="R">Type of result.</typeparam>
            <param name="source">List to fold.</param>
            <param name="initialValue">From were to start.</param>
            <param name="collect">Collects list item into result</param>
            <returns>Return result or <paramref name="initialValue"/> for empty list.</returns>
        </member>
        <member name="M:ImTools.ImList.Reverse``1(ImTools.ImList{``0})">
            <summary>Returns new list in reverse order.</summary>
            <typeparam name="T">List item type</typeparam> <param name="source">List to reverse.</param>
            <returns>New list. If list consist on single element, then the same list.</returns>
        </member>
        <member name="M:ImTools.ImList.Map``2(ImTools.ImList{``0},System.Func{``0,``1})">
            <summary>Maps the items from the first list to the result list.</summary>
            <typeparam name="T">source item type.</typeparam> 
            <typeparam name="R">result item type.</typeparam>
            <param name="source">input list.</param> <param name="map">converter func.</param>
            <returns>result list.</returns>
        </member>
        <member name="M:ImTools.ImList.Map``2(ImTools.ImList{``0},System.Func{``0,System.Int32,``1})">
            <summary>Maps the items from the first list to the result list with item index.</summary>
            <typeparam name="T">source item type.</typeparam> 
            <typeparam name="R">result item type.</typeparam>
            <param name="source">input list.</param> <param name="map">converter func.</param>
            <returns>result list.</returns>
        </member>
        <member name="M:ImTools.ImList.ToArray``1(ImTools.ImList{``0})">
            <summary>Copies list to array.</summary> 
        </member>
        <member name="T:ImTools.Update`1">
            Given the old value should and the new value should return result updated value.
        </member>
        <member name="T:ImTools.Update`2">
            Update handler including the key
        </member>
        <member name="T:ImTools.ImMap`1">
            <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree with integer keys and <typeparamref name="V"/> values.</summary>
        </member>
        <member name="F:ImTools.ImMap`1.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="F:ImTools.ImMap`1.Key">
            <summary>Key.</summary>
        </member>
        <member name="F:ImTools.ImMap`1.Value">
            <summary>Value.</summary>
        </member>
        <member name="F:ImTools.ImMap`1.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImMap`1.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImMap`1.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:ImTools.ImMap`1.IsEmpty">
            <summary>Returns true is tree is empty.</summary>
        </member>
        <member name="M:ImTools.ImMap`1.AddOrUpdate(System.Int32,`0)">
            Returns a new tree with added or updated value for specified key.
        </member>
        <member name="M:ImTools.ImMap`1.AddOrUpdate(System.Int32,`0,ImTools.Update{`0})">
            <summary>Returns new tree with added or updated value for specified key.</summary>
            <param name="key">Key</param> <param name="value">Value</param>
            <param name="updateValue">(optional) Delegate to calculate new value from and old and a new value.</param>
            <returns>New tree.</returns>
        </member>
        <member name="M:ImTools.ImMap`1.Update(System.Int32,`0)">
            <summary>Returns new tree with updated value for the key, Or the same tree if key was not found.</summary>
            <param name="key"></param> <param name="value"></param>
            <returns>New tree if key is found, or the same tree otherwise.</returns>
        </member>
        <member name="M:ImTools.ImMap`1.Enumerate">
            <summary>Returns all sub-trees enumerated from left to right.</summary> 
            <returns>Enumerated sub-trees or empty if tree is empty.</returns>
        </member>
        <member name="M:ImTools.ImMap`1.Remove(System.Int32)">
            <summary>Removes or updates value for specified key, or does nothing if key is not found.
            Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
            <param name="key">Key to look for.</param> 
            <returns>New tree with removed or updated value.</returns>
        </member>
        <member name="M:ImTools.ImMap`1.ToString">
            <summary>Outputs key value pair</summary>
        </member>
        <member name="T:ImTools.ImMap">
            ImMap methods
        </member>
        <member name="M:ImTools.ImMap.GetValueOrDefault``1(ImTools.ImMap{``0},System.Int32,``0)">
            Get value for found key or default value otherwise.
        </member>
        <member name="M:ImTools.ImMap.TryFind``1(ImTools.ImMap{``0},System.Int32,``0@)">
            Returns true if key is found and sets the value.
        </member>
        <member name="T:ImTools.ImHashMap`2">
            <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree 
            where node key is the hash code of <typeparamref name="K"/>.</summary>
        </member>
        <member name="F:ImTools.ImHashMap`2.Empty">
            <summary>Empty tree to start with.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.Hash">
            <summary>Calculated key hash.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.Key">
            <summary>Key of type K that should support <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.Value">
            <summary>Value of any type V.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.Conflicts">
            <summary>In case of <see cref="P:ImTools.ImHashMap`2.Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        </member>
        <member name="F:ImTools.ImHashMap`2.Left">
            <summary>Left sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImHashMap`2.Right">
            <summary>Right sub-tree/branch, or empty.</summary>
        </member>
        <member name="F:ImTools.ImHashMap`2.Height">
            <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        </member>
        <member name="P:ImTools.ImHashMap`2.IsEmpty">
            <summary>Returns true if tree is empty.</summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrUpdate(`0,`1)">
            <summary>Returns new tree with added key-value. 
            If value with the same key is exist then the value is replaced.</summary>
            <param name="key">Key to add.</param><param name="value">Value to add.</param>
            <returns>New tree with added or updated key-value.</returns>
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrUpdate(`0,`1,ImTools.Update{`1})">
            <summary>Returns new tree with added key-value. If value with the same key is exist, then
            if <paramref name="update"/> is not specified: then existing value will be replaced by <paramref name="value"/>;
            if <paramref name="update"/> is specified: then update delegate will decide what value to keep.</summary>
            <param name="key">Key to add.</param><param name="value">Value to add.</param>
            <param name="update">Update handler.</param>
            <returns>New tree with added or updated key-value.</returns>
        </member>
        <member name="M:ImTools.ImHashMap`2.AddOrUpdate(`0,`1,System.Boolean@,`1@,ImTools.Update{`0,`1})">
            Allocation free for `update` using the key
        </member>
        <member name="M:ImTools.ImHashMap`2.Update(`0,`1,ImTools.Update{`1})">
            <summary>Looks for <paramref name="key"/> and replaces its value with new <paramref name="value"/>, or 
            runs custom update handler (<paramref name="update"/>) with old and new value to get the updated result.</summary>
            <param name="key">Key to look for.</param>
            <param name="value">New value to replace key value with.</param>
            <param name="update">(optional) Delegate for custom update logic, it gets old and new <paramref name="value"/>
            as inputs and should return updated value as output.</param>
            <returns>New tree with updated value or the SAME tree if no key found.</returns>
        </member>
        <member name="M:ImTools.ImHashMap`2.Enumerate">
            <summary>Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
            The only difference is using fixed size array instead of stack for speed-up (~20% faster than stack).</summary>
            <returns>Sequence of enumerated key value pairs.</returns>
        </member>
        <member name="M:ImTools.ImHashMap`2.Remove(`0)">
            <summary>Removes or updates value for specified key, or does nothing if key is not found.
            Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
            <param name="key">Key to look for.</param> 
            <returns>New tree with removed or updated value.</returns>
        </member>
        <member name="M:ImTools.ImHashMap`2.ToString">
            <summary>Outputs key value pair</summary>
        </member>
        <member name="M:ImTools.ImHashMap`2.Update(System.Int32,`0,`1,ImTools.Update{`1})">
            It is fine, made public for testing.
        </member>
        <member name="M:ImTools.ImHashMap`2.GetConflictedValueOrDefault(`0,`1)">
            It is fine to be public.
        </member>
        <member name="M:ImTools.ImHashMap`2.TryFindConflictedValue(`0,`1@)">
            Does it
        </member>
        <member name="T:ImTools.ImHashMap">
            ImHashMap methods for faster performance
        </member>
        <member name="M:ImTools.ImHashMap.GetValueOrDefault``2(ImTools.ImHashMap{``0,``1},``0,``1)">
            Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        </member>
        <member name="M:ImTools.ImHashMap.GetValueOrDefault``1(ImTools.ImHashMap{System.Type,``0},System.Type,``0)">
            Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        </member>
        <member name="M:ImTools.ImHashMap.TryFind``2(ImTools.ImHashMap{``0,``1},``0,``1@)">
            Returns true if key is found and sets the value.
        </member>
        <member name="M:ImTools.ImHashMap.TryFind``1(ImTools.ImHashMap{System.Type,``0},System.Type,``0@)">
            Returns true if key is found and sets the value.
        </member>
    </members>
</doc>
